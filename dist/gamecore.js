;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Context2d;

Context2d = (function() {
  function Context2d(options) {
    this.setCanvas(options.canvas);
  }

  Context2d.prototype.setCanvas = function(canvas) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    return this;
  };

  Context2d.prototype.clear = function() {
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    return this;
  };

  Context2d.prototype.render = function(layers) {
    var layer, _i, _len, _results;
    if (layers == null) {
      layers = [];
    }
    this.clear();
    _results = [];
    for (_i = 0, _len = layers.length; _i < _len; _i++) {
      layer = layers[_i];
      _results.push(layer.render(this.ctx));
    }
    return _results;
  };

  return Context2d;

})();

module.exports = Context2d;

/*
//File: 2d.js
*/

},{}],2:[function(require,module,exports){
(function(){// Generated by CoffeeScript 1.6.3
var GameCore, Stage, Triggerable, UUID, context2d, support,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

context2d = require("./context/2d");

support = require("./support");

Triggerable = require("./triggerable");

UUID = require("../math/uuid");

Stage = require("../ui/stage");

/*
Game Core base class

@property {Stage} stage
@property {Boolean} fullWindowSize
@property {Boolean} paused
@property {Context} context
@property {Int} width
@property {Int} heigth
@property {DOMElement} renderer

@example How to create an game core 
    gc = new GameCore() # Creating core
    gc.renderer = document.body # Appends new canvas element to documents body

@example Making canvas full-sized
    gc = new GameCore() # Creating core
    gc.fullWindowSize = true
*/


GameCore = (function(_super) {
  __extends(GameCore, _super);

  /*
  GameCore instancec archive
  */


  GameCore.cores = {};

  /*
  Start your application from here.
  
  @param {Object} options
  */


  function GameCore(options) {
    var error, _i, _len, _ref;
    this.options = options != null ? options : {};
    GameCore.__super__.constructor.call(this, this.options);
    /*
    In the first case we need to generate id for new instance, if it not
     present in options.
    */

    this.id = this.options.id || UUID.generateUniqueId();
    /*
    Checing for runtime errors
    */

    if (support.ERRORS) {
      _ref = support.ERRORS;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        error = _ref[_i];
        throw error;
      }
    }
    /*
    Setting up a canvas.
    If canvas doesn't present in options then create it.
    */

    this.options.canvas = this.options.canvas || this.createCanvas();
    /*
    Registrating GameCore instance in canvas ang GameCore global.
    */

    this.options.canvas.core = this;
    GameCore.cores[this.id] = this;
    /*
    Setting up framerate
    */

    this.setFramerate();
    /*
    Stages map
    */

    this._stages = {};
    Object.defineProperty(this, "stage", {
      get: function() {
        var stage;
        if (this._current_stage_id) {
          return this._stages[this._current_stage_id];
        } else {
          stage = new Stage;
          this._current_stage_id = stage.id;
          this.addStage(stage);
          return stage;
        }
      },
      set: function(stage) {
        if (!this._stages[stage.id]) {
          this.addStage(stage);
        }
        this._current_stage_id = stage.id;
        return this.trigger('stage_changed', stage);
      }
    });
    /*
    */

    Object.defineProperty(this, "fullWindowSize", {
      get: function() {
        return this._in_the_fullscreen_now;
      },
      set: function(b) {
        if (b === true) {
          window.addEventListener("resize", this._fullWindowSize_resizer);
          this._in_the_fullscreen_now = true;
          return this.setSize(document.width, document.height);
        } else {
          window.removeEventListener("resize", this._fullWindowSize_resizer);
          this._in_the_fullscreen_now = false;
          return this.setSize(this.options.width, this.options.height);
        }
      }
    });
    this.fullWindowSize = this.options.fullWindowSize;
    /*
    */

    Object.defineProperty(this, "width", {
      get: function() {
        return this.options.canvas.width;
      },
      set: function(width) {
        this.options.canvas.width = width;
        return this.options.canvas.style.width = width + "px";
      }
    });
    /*
    */

    Object.defineProperty(this, "height", {
      get: function() {
        return this.options.canvas.height;
      },
      set: function(height) {
        this.options.canvas.height = height;
        return this.options.canvas.style.height = height + "px";
      }
    });
    if (this.fullWindowSize) {
      this.options.width = window.width;
      this.options.height = window.height;
    }
    this.setSize(this.options.width, this.options.height);
    /*
    Context element.
    Currently support only Context2d
    */

    Object.defineProperty(this, "context", {
      get: function() {
        if (!this._context) {
          this._context = new context2d({
            canvas: this.options.canvas
          });
        }
        return this._context;
      }
    });
    /*
    */

    Object.defineProperty(this, "paused", {
      get: function() {
        return this._paused || false;
      },
      set: function(paused) {
        return this._paused = paused ? true : false;
      }
    });
    /*
    Renderer element.
    */

    Object.defineProperty(this, "renderer", {
      get: function() {
        return this._parent_node || 'undefined';
      },
      set: function(node) {
        if (!node.tagName) {
          throw Error("Can render only on document elements");
        }
        node.appendChild(this.options.canvas);
        return this._parent_node = node;
      }
    });
    this._onEnterFrame();
  }

  /*
  */


  GameCore.prototype.addStage = function(stage, setCurrent) {
    if (setCurrent == null) {
      setCurrent = false;
    }
    stage = stage || new Stage;
    this._stages[stage.id] = stage;
    if (setCurrent) {
      this.stage = stage.id;
    }
    this.trigger('stage_added', stage);
    return stage;
  };

  /*
  Switch pause state
  */


  GameCore.prototype.pause = function() {
    this.paused = !this.paused;
    if (this.paused) {
      return this.trigger('paused');
    } else {
      return this.trigger('unpaused');
    }
  };

  /*
  Set's framerate. Not usable at the moment...
  @param {Int} framerate
  @method setFramerate
  */


  GameCore.prototype.setFramerate = function(framerate) {
    if (framerate == null) {
      framerate = 60;
    }
    return window._FPS = framerate;
  };

  /*
  Set size of an canvas element.
  @param {Int} width
  @param {Int} height
  @method setSize
  */


  GameCore.prototype.setSize = function(width, height) {
    if (width == null) {
      width = 400;
    }
    if (height == null) {
      height = 300;
    }
    this.width = width;
    this.height = height;
    return this.trigger('sizeChanged', width, height);
  };

  GameCore.prototype._fullWindowSize_resizer = function() {
    var gci;
    gci = this;
    return function(e) {
      return gci.setSize(window.width, window.height);
    };
  };

  /*
  Creates a canvas element
  @method createCanvas
  */


  GameCore.prototype.createCanvas = function() {
    var canvas;
    canvas = document.createElement('canvas');
    return canvas;
  };

  /*
  Call window's requestAnimationFrame.
  @method _onEnterFrame
  */


  GameCore.prototype._onEnterFrame = function(gci) {
    if (gci == null) {
      gci = this;
    }
    if (!this.paused) {
      gci._render(gci.stage);
    }
    return window.onEnterFrame(function() {
      return gci._onEnterFrame(gci);
    });
  };

  GameCore.prototype._render = function() {
    this.trigger('render_start');
    this.stage.width = this.width;
    this.stage.height = this.height;
    this.context.render([this.stage]);
    this.trigger('render_end');
    return this.trigger('render');
  };

  return GameCore;

})(Triggerable);

module.exports = GameCore;

/*
//File: core.js
*/

})()
},{"../math/uuid":9,"../ui/stage":17,"./context/2d":1,"./support":3,"./triggerable":4}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var ERRORS, browserPrefix, prefix, userAgent;

prefix = function(name) {
  if (browserPrefix !== "") {
    name = name.charAt(0).toUpperCase() + name.slice(1);
  }
  return browserPrefix + name;
};

userAgent = navigator.userAgent;

browserPrefix = (userAgent.match(/opera/i) && "o") || (userAgent.match(/webkit/i) && "webkit") || (userAgent.match(/msie/i) && "ms") || (userAgent.match(/mozilla/i) && "moz") || "";

Function.prototypeproperty = function(prop, desc) {
  return Object.defineProperty(this.prototype, prop, desc);
};

if (typeof window.addEventListener !== "function") {
  HTMLElement.prototypeaddEventListener = function(type, callback, useCapture) {
    return attachEvent("on" + type, callback);
  };
}

/*
window.onEnterFrame
*/


window.onEnterFrame = (function() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
    return window.setTimeout(callback, 1000 / window._FPS);
  };
})();

/*
Working around Typed arrays
*/


(function() {
  /*
  Trying to create Uint8Array. 
  If everything is ok then return, otherwise we need to create a simulation.
  
  Code borrowed from pdf.js (https://gist.github.com/1057924)
  */

  var TypedArray, a, set_, subarray;
  try {
    a = new Uint8Array(1);
    return;
  } catch (_error) {}
  subarray = function(start, end) {
    return this.slice(start, end);
  };
  set_ = function(array, offset) {
    var i, n, _results;
    i = void 0;
    n = array.length;
    if (arguments_.length < 2) {
      offset = 0;
    }
    i = 0;
    _results = [];
    while (i < n) {
      this[offset] = array[i] & 0xFF;
      ++i;
      _results.push(++offset);
    }
    return _results;
  };
  TypedArray = function(arg1) {
    var i, result;
    result = void 0;
    i = void 0;
    if (typeof arg1 === "number") {
      result = new Array(arg1);
      i = 0;
      while (i < arg1) {
        result[i] = 0;
        ++i;
      }
    } else {
      result = arg1.slice(0);
    }
    result.subarray = subarray;
    result.buffer = result;
    result.byteLength = result.length;
    result.set = set_;
    if (typeof arg1 === "object" && arg1.buffer) {
      result.buffer = arg1.buffer;
    }
    return result;
  };
  window.Uint8Array = TypedArray;
  window.Uint32Array = TypedArray;
  return window.Int32Array = TypedArray;
})();

(function() {
  var getter;
  if (window.opera) {
    return;
  }
  if ("response" in XMLHttpRequest.prototype || "mozResponseArrayBuffer" in XMLHttpRequest.prototype || "mozResponse" in XMLHttpRequest.prototype || "responseArrayBuffer" in XMLHttpRequest.prototype) {
    return;
  }
  getter = void 0;
  if (window.VBArray) {
    getter = function() {
      return new Uint8Array(new VBArray(this.responseBody).toArray());
    };
  } else {
    getter = function() {
      return this.responseBody;
    };
  }
  return Object.defineProperty(XMLHttpRequest.prototype, "response", {
    get: getter
  });
})();

if (!window.btoa) {
  (function() {
    return window.btoa = function(data) {
      var ac, b64, bits, enc, h1, h2, h3, h4, i, o1, o2, o3, r, tmp_arr;
      b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      o1 = void 0;
      o2 = void 0;
      o3 = void 0;
      h1 = void 0;
      h2 = void 0;
      h3 = void 0;
      h4 = void 0;
      bits = void 0;
      i = 0;
      ac = 0;
      enc = "";
      tmp_arr = [];
      if (!data) {
        return data;
      }
      while (true) {
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);
        bits = o1 << 16 | o2 << 8 | o3;
        h1 = bits >> 18 & 0x3f;
        h2 = bits >> 12 & 0x3f;
        h3 = bits >> 6 & 0x3f;
        h4 = bits & 0x3f;
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
        if (!(i < data.length)) {
          break;
        }
      }
      enc = tmp_arr.join("");
      r = data.length % 3;
      return (r ? enc.slice(0, r - 3) : enc) + "===".slice(r || 3);
    };
  })();
}

/*
Checking for ability to work
*/


ERRORS = [];

if (!Object.defineProperty) {
  ERRORS.append("Browser doesnt support Object.defineProperty.");
}

if (!document.createElement("canvas").getContext) {
  ERRORS.append("Browser doesnt support <canvas> and the Canvas2D API.");
}

module.exports = {
  /*
  */

  ERRORS: ERRORS,
  /*
  Browser's user-agent string
  @attribute userAgent
  @type {String}
  @static
  @readonly
  */

  userAgent: userAgent,
  /*
  Device supports touch events?
  @attribute touch
  @type {Boolean}
  @static
  @readonly
  */

  touch: "ontouchstart" in window,
  /*
  Device supports Retina Display?
  @attribute retina
  @type {Boolean}
  @static
  @readonly
  */

  retina: window.devicePixelRatio > 1 || window.matchMedia("(min-resolution: 1.1dppx)").matches,
  imageSmoothingEnabled: prefix("imageSmoothingEnabled")
};

/*
//File: support.js
*/

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Events, Triggerable, support,
  __slice = [].slice;

support = require('./support');

Events = {
  INIT: 'init'
};

Triggerable = (function() {
  /*
  Event triggering and handling.
  
  @class Triggerable
  @constructor
  */

  function Triggerable(options) {
    var k, v;
    if (options == null) {
      options = {};
    }
    this.events = this.events || {};
    for (k in Events) {
      v = Events[k];
      this.events[k] = v;
    }
    this._handlers = options._handlers || {};
    this._behaviours = options._behaviours || [];
  }

  /*
  Behave like a {Behaviour}
  @method behave
  @param {String | Behaviour} behaviour
  @return {Triggerable} this
  */


  Triggerable.prototype.behave = function(Behaviour, options) {
    var behaviour, behaviours, i, l, last;
    i = void 0;
    if (typeof Behaviour === "string") {
      last = void 0;
      behaviours = Behaviour.split(",");
      i = 0;
      l = behaviours.length;
      while (i < l) {
        last = this.behave(Behaviours.get(behaviours[i].replace(" ", "")), options);
        i++;
      }
      return last;
    }
    this._behaviours.push(Behaviour.id);
    behaviour = new Behaviour(options);
    for (i in behaviour) {
      if (typeof this.events[i] === "string") {
        this.bind(this.events[i], behaviour[i]);
      } else {
        if (i !== "constructor") {
          this[i] = behaviour[i];
        }
      }
    }
    return this;
  };

  /*
  This object behaves as {target} behaviour?
  @method hasBehaviour
  @param {String} behaviourName
  @return {Boolean}
  */


  Triggerable.prototype.hasBehaviour = function(behaviour) {
    return this._behaviours.indexOf(behaviour) >= 0;
  };

  /*
  Bind event handler
  @method bind
  @param {String} type event type
  @param {Function} handler
  @return {Triggerable} this
  */


  Triggerable.prototype.bind = function(type, handler) {
    var data;
    data = handler;
    if (Triggerable._custom.bind[type] !== undefined) {
      data = {
        target: this,
        handler: handler
      };
      Triggerable._custom.bind[type].call(this, data);
    }
    if (this._handlers[type] === undefined) {
      this._handlers[type] = [];
    }
    if (this._handlers[type].indexOf(data) === -1) {
      this._handlers[type].push(data);
    }
    return this;
  };

  /*
  Remove event handlers
  @method unbind
  @param {String} type event type
  @return {Triggerable} this
  */


  Triggerable.prototype.unbind = function(type) {
    var i, length;
    if (Triggerable._custom.unbind[type] !== undefined) {
      i = 0;
      length = this._handlers[type].length;
      while (i < length) {
        Triggerable._custom.unbind[type].call(this, this._handlers[type][i]);
        ++i;
      }
    }
    this._handlers[type] = null;
    return this;
  };

  /*
  Triggers event type
  @method trigger
  @param {String} type event type
  @param {Variable} arguments arguments for callback
  @optional
  */


  Triggerable.prototype.trigger = function() {
    var args, handlers, i, length, type, _ref, _results;
    type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    handlers = this._handlers[type] || [];
    args = args || [];
    i = 0;
    length = handlers.length;
    _results = [];
    while (i < length) {
      (_ref = handlers[i]).apply.apply(_ref, [this].concat(__slice.call(args)));
      _results.push(++i);
    }
    return _results;
  };

  Triggerable._custom = {
    bind: {},
    unbind: {}
  };

  /*
  Register default method handler.
  @method register
  @param {String} type
  @param {Function} bindCallback
  @param {Function} unbindCallback
  
  @static
  */


  Triggerable.register = function(type, bindCallback, unbindCallback) {
    Triggerable._custom.bind[type] = bindCallback;
    Triggerable._custom.unbind[type] = unbindCallback;
    return this;
  };

  Triggerable.register(Events.INIT, function(evt) {
    return evt.handler.call(this);
  });

  return Triggerable;

})();

module.exports = Triggerable;

/*
//File: triggerable.js
*/

},{"./support":3}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var support;

support = require("./core/support");

window.GameCore = window.GameCore || require("./core/core");

window.GameCore.exports = {
  UI: require("./ui/exports"),
  Math: require("./math/exports"),
  Utils: require("./utils/exports")
};

module.exports = GameCore;

/*
//File: gamecore.js
*/

},{"./core/core":2,"./core/support":3,"./math/exports":6,"./ui/exports":12,"./utils/exports":21}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
module.exports = {
  Matrix2D: require("./matrix2d"),
  Vector2D: require("./vector2d"),
  UUID: require("./uuid"),
  Math: require("./math")
};

/*
//File: exports.js
*/

},{"./math":7,"./matrix2d":8,"./uuid":9,"./vector2d":10}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
Mathematical functions

@note GameCore.exports.Math.Math

@see http://docs.closure-library.googlecode.com/git-history/418ef20b29e8f3ebb5121266ec7206ae6943d28d/closure_goog_math_math.js.source.html
*/

var Mathematics;

Mathematics = (function() {
  function Mathematics() {}

  /*
  Clamping a number into a limits
  
  @method clamp
  @param {Number} num
  @param {Number} min
  @param {Number} max
  @return {Number}
  */


  Mathematics.clamp = function(num, min, max) {
    return Math.min(Math.max(num, min), max);
  };

  /*
  Alias to @clamp(num, 0, 1)
  
  @method clamp01
  @param {Number} num
  @return {Number}
  */


  Mathematics.clamp01 = function(num) {
    return this.clamp(num, 0, 1);
  };

  /*
  Returns a random integer greater than or equal to $min and less than $max.
  
  @param {Number} a  The lower bound for the random integer inclusive (default=0).
  @param {Number} a  The upper bound for the random integer exlusive (default=1000).
  @return {Number} A random integer N such that $min <= N < $max.
  */


  Mathematics.randomInt = function(min, max) {
    if (min == null) {
      min = 0;
    }
    if (max == null) {
      max = 100;
    }
    return Math.floor(min + Math.random() * (max - min));
  };

  /*
  The % operator in JavaScript returns the remainder of a / b, but differs from
  some other languages in that the result will have the same sign as the
  dividend. For example, -1 % 8 == -1, whereas in some other languages
  (such as Python) the result would be 7. This function emulates the more
  correct modulo behavior, which is useful for certain applications such as
  calculating an offset index in a circular list.
   
  @param {number} a The dividend.
  @param {number} b The divisor.
  @return {number} a % b where the result is between 0 and b (either 0 <= x < b
    or b < x <= 0, depending on the sign of b).
  */


  Mathematics.modulo = function(a, b) {
    var r;
    r = a % b;
    if (r * b < 0) {
      return r + b;
    } else {
      return r;
    }
  };

  /*
  Performs linear interpolation between values a and b. Returns the value
  between a and b proportional to x (when x is between 0 and 1. When x is
  outside this range, the return value is a linear extrapolation).
  
  @param {number} a A number.
  @param {number} b A number.
  @param {number} x The proportion between a and b.
  @return {number} The interpolated value between a and b.
  */


  Mathematics.lerp = function(a, b, x) {
    return a + x * (b - a);
  };

  /*
  Tests whether the two values are equal to each other, within a certain
  tolerance to adjust for floating pount errors.
  
  @param {Number} a A number.
  @param {Number} b A number.
  @param {Number=} opt_tolerance Optional tolerance range.
      Defaults to 0.000001. If specified, should be greater than 0.
  @return {Boolean} Whether $a and $b are nearly equal.
  */


  Mathematics.nearlyEquals = function(a, b, opt_tolerance) {
    if (opt_tolerance == null) {
      opt_tolerance = 0.000001;
    }
    return Math.abs(a - b) <= opt_tolerance;
  };

  return Mathematics;

})();

module.exports = Mathematics;

/*
//File: math.js
*/

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
2D Matrix manipulations

@note GameCore.exports.Math.Matrix2D
*/

var Matrix2D;

Matrix2D = (function() {
  /*           
  Multiplier for converting degrees to radians. Used internally by Matrix2D.
  
  @attribute DEG_TO_RAD
  @static
  @readonly
  @return {Number}
  */

  Matrix2D.DEG_TO_RAD = Math.PI / 180;

  /*
  Based on [EaselJS](https://github.com/CreateJS/EaselJS/) Matrix2D implementation.
  
  @class Matrix2D
  @constructor
  
  @param {Number} m11
  @param {Number} m12
  @param {Number} m21
  @param {Number} m22
  @param {Number} dx
  @param {Number} dy
  */


  function Matrix2D(m11, m12, m21, m22, dx, dy) {
    if (m11 !== null) {
      this.m11 = m11;
    }
    this.m12 = m12 || 0;
    this.m21 = m21 || 0;
    if (m22 !== null) {
      this.m22 = m22;
    }
    this.dx = dx || 0;
    this.dy = dy || 0;
  }

  /*
  Generates matrix properties from the specified display object transform properties, and appends them with this matrix.
  For example, you can use this to generate m11 matrix from m11 display object: var mtx = new Matrix2D();
  mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
  @method appendTransform
  @param {Number} x
  @param {Number} y
  @param {Number} scaleX
  @param {Number} scaleY
  @param {Number} rotation
  @param {Number} skewX
  @param {Number} skewY
  @param {Number} pivotX Optional.
  @param {Number} pivotY Optional.
  @return {Matrix2D} This matrix. Useful for chaining method calls.
  */


  Matrix2D.prototype.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
    var cos, r, sin;
    cos = void 0;
    sin = void 0;
    r = void 0;
    if (rotation % 360) {
      r = rotation * Matrix2D.DEG_TO_RAD;
      cos = Math.cos(r);
      sin = Math.sin(r);
    } else {
      cos = 1;
      sin = 0;
    }
    if (skewX || skewY) {
      skewX *= Matrix2D.DEG_TO_RAD;
      skewY *= Matrix2D.DEG_TO_RAD;
      this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
      this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
    } else {
      this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
    }
    if (pivotX || pivotY) {
      this.dx -= pivotX * this.m11 + pivotY * this.m21;
      this.dy -= pivotX * this.m12 + pivotY * this.m22;
    }
    return this;
  };

  /*
  Appends the specified matrix properties with this matrix. All parameters are required.
  @method append
  @param {Number} m11
  @param {Number} m12
  @param {Number} m21
  @param {Number} m22
  @param {Number} dx
  @param {Number} dy
  @return {Matrix2D} This matrix. Useful for chaining method calls.
  */


  Matrix2D.prototype.append = function(m11, m12, m21, m22, dx, dy) {
    var a1, b1, c1, d1;
    a1 = this.m11;
    b1 = this.m12;
    c1 = this.m21;
    d1 = this.m22;
    this.m11 = m11 * a1 + m12 * c1;
    this.m12 = m11 * b1 + m12 * d1;
    this.m21 = m21 * a1 + m22 * c1;
    this.m22 = m21 * b1 + m22 * d1;
    this.dx = dx * a1 + dy * c1 + this.dx;
    this.dy = dx * b1 + dy * d1 + this.dy;
    return this;
  };

  /*
  Inverts the matrix, causing it to perform the opposite transformation.
  @method invert
  @return {Matrix2D} this
  */


  Matrix2D.prototype.invert = function() {
    var a1, b1, c1, d1, n, tx1;
    a1 = this.m11;
    b1 = this.m12;
    c1 = this.m21;
    d1 = this.m22;
    tx1 = this.dx;
    n = a1 * d1 - b1 * c1;
    this.m11 = d1 / n;
    this.m12 = -b1 / n;
    this.m21 = -c1 / n;
    this.m22 = a1 / n;
    this.dx = (c1 * this.dy - d1 * tx1) / n;
    this.dy = -(a1 * this.dy - b1 * tx1) / n;
    return this;
  };

  /*
  Clone Matrix2D instance
  @return {Matrix2D}
  */


  Matrix2D.prototype.clone = function() {
    return new Matrix2D(this.m11, this.m12, this.m21, this.m22, this.dx, this.dy);
  };

  /*
  Reset matrix to it's identity
  @return {Matrix2D} this
  */


  Matrix2D.prototype.identity = function() {
    this.m11 = this.m22 = 1;
    this.m12 = this.m21 = this.dx = this.dy = 0;
    return this;
  };

  Matrix2D.identity = new Matrix2D(1, 0, 0, 1, 0, 0);

  return Matrix2D;

})();

module.exports = Matrix2D;

/*
//File: matrix2d.js
*/

},{}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
Unique ID generator

@note GameCore.exports.Math.UUID
*/

var UUID;

UUID = (function() {
  function UUID() {}

  /*
  @method generateUniqueId
  @return {String}
  */


  UUID.generateUniqueId = function() {
    return "gc-" + this.uuid();
  };

  /*
  @method uuid
  @return {String}
  */


  UUID.uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  return UUID;

})();

module.exports = UUID;

/*
//File: uuid.js
*/

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
2D Vector manipulations

@note GameCore.exports.Math.Vector2D
*/

var Vector2d;

Vector2d = (function() {
  function Vector2d(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
    /*
    Get the magnitude of this vector
    @attribute length
    @readonly
    */

    Object.defineProperty(this, "length", {
      get: function() {
        return Math.sqrt((this.x * this.x) + (this.y * this.y));
      },
      configurable: true
    });
    /*
    Get this vector with a magnitude of 1.
    @attribute normalized
    @readonly
    */

    Object.defineProperty(this, "normalized", {
      get: function() {
        var magnitude;
        magnitude = this.length;
        return new Vector2d(this.x / magnitude, this.y / magnitude);
      },
      configurable: true
    });
  }

  /*
  @method set
  @param {Number} x
  @param {Number} y
  @return {Vector2d}
  */


  Vector2d.prototype.set = function(x, y) {
    this.x = x;
    this.y = y;
  };

  /*
  @method sum
  @param {Vector2d} vector2d
  @return {Vector2d}
  */


  Vector2d.prototype.subtract = function(vector2d) {
    this.x -= vector2d.x;
    return this.y -= vector2d.y;
  };

  /*
  @method sum
  @param {Vector2d} vector2d
  @return {Vector2d}
  */


  Vector2d.prototype.sum = function(vector2d) {
    this.x += vector2d.x;
    return this.y += vector2d.y;
  };

  /*
  @method scale
  @param {Number} x (or x y)
  @param {Number} y
  @return {Vector2d}
  */


  Vector2d.prototype.scale = function(x, y) {
    this.x *= x;
    return this.y *= y || x;
  };

  /*
  @method clone
  @return {Vector2d}
  */


  Vector2d.prototype.clone = function() {
    return new Vector2d(this.x, this.y);
  };

  /*
  Return unit vector
  @return {Vector2d}
  */


  Vector2d.prototype.unit = function() {
    return new Vector2d(Math.cos(this.x), Math.sin(this.y));
  };

  /*
  Normalize this vector
  @return {Vector2d}
  */


  Vector2d.prototype.normalize = function() {
    var normal;
    normal = this.normalized;
    this.x = normal.x;
    return this.y = normal.y;
  };

  /*
  Get the distance between this vector and the argument vector
  @param {Vector2d} vector
  @return {Number}
  */


  Vector2d.distance = function(v1, v2) {
    var xdiff, ydiff;
    xdiff = v1.x - v2.x;
    ydiff = v1.y - v2.y;
    return Math.sqrt(xdiff * xdiff + ydiff * ydiff);
  };

  /*
  @method toString
  @return {String}
  */


  Vector2d.prototype.toString = function() {
    return "#<Vector2d @x=" + this.x + ", @y=" + this.y + ">";
  };

  Vector2d.LEFT = new Vector2d(-1, 0);

  Vector2d.RIGHT = new Vector2d(1, 0);

  Vector2d.TOP = new Vector2d(0, -1);

  Vector2d.BOTTOM = new Vector2d(0, 1);

  return Vector2d;

})();

module.exports = Vector2d;

/*
//File: vector2d.js
*/

},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Container, Widget,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Widget = require("./widget");

/*
Base widgets container
@note GameCore.exports.ui.Container
*/


Container = (function(_super) {
  __extends(Container, _super);

  function Container(options) {
    if (options == null) {
      options = {};
    }
    Container.__super__.constructor.call(this, options);
    this.children = {};
  }

  Container.prototype.addChild = function(child) {
    if (child.parent === !this) {
      return child.parent = this;
    } else {
      return this.children[child.id] = child;
    }
  };

  Container.prototype.render = function(ctx) {
    var child, cid, _ref, _results;
    Container.__super__.render.call(this, ctx);
    _ref = this.children;
    _results = [];
    for (cid in _ref) {
      child = _ref[cid];
      _results.push(child.render(ctx));
    }
    return _results;
  };

  return Container;

})(Widget);

module.exports = Container;

/*
//File: container.js
*/

},{"./widget":19}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
module.exports = {
  Widget: require("./widget"),
  Stage: require("./stage"),
  Container: require("./container"),
  Text: require("./text"),
  Sprite: require("./sprite"),
  geometry: require("./geometry/exports")
};

/*
//File: exports.js
*/

},{"./container":11,"./geometry/exports":14,"./sprite":16,"./stage":17,"./text":18,"./widget":19}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Circle, Widget,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Widget = require("../widget");

Circle = (function(_super) {
  __extends(Circle, _super);

  function Circle(options) {
    if (options == null) {
      options = {};
    }
    Circle.__super__.constructor.call(this, options);
  }

  return Circle;

})(Widget);

/*
//File: circle.js
*/

},{"../widget":19}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
module.exports = {
  Circle: require("./circle"),
  Rect: require("./rect")
};

/*
//File: exports.js
*/

},{"./circle":13,"./rect":15}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Rect, Widget,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Widget = require("../widget");

Rect = (function(_super) {
  __extends(Rect, _super);

  function Rect(options) {
    if (options == null) {
      options = {};
    }
    Rect.__super__.constructor.call(this, options);
  }

  return Rect;

})(Widget);

/*
//File: rect.js
*/

},{"../widget":19}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Color, Sprite, Widget,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Widget = require("./widget");

Color = require("../utils/color");

Sprite = (function(_super) {
  __extends(Sprite, _super);

  function Sprite(options) {
    var self;
    if (options == null) {
      options = {};
    }
    Sprite.__super__.constructor.call(this, options);
    self = this;
    this.loaded = false;
    if (!options.image) {
      if (!options.src) {
        throw new Error('Not found required `src` or `image` atribute in options.');
      }
      this.image = new Image();
      this.image.src = options.src;
    } else {
      this.image = options.image;
    }
    this.image.addEventListener('load', function() {
      return self.on_load.apply(self, [options.width || false, options.height || false]);
    });
  }

  Sprite.prototype.on_load = function(w, h) {
    this.loaded = true;
    if (!w) {
      this.width = this.image.width;
    }
    if (!h) {
      return this.height = this.image.height;
    }
  };

  Sprite.prototype._render = function(ctx) {
    if (this.loaded) {
      return ctx.drawImage(this.image, 0, 0, this.width, this.height);
    } else {
      return ctx.fillRect(0, 0, this.width, this.height);
    }
  };

  return Sprite;

})(Widget);

module.exports = Sprite;

/*
//File: sprite.js
*/

},{"../utils/color":20,"./widget":19}],17:[function(require,module,exports){
(function(){// Generated by CoffeeScript 1.6.3
var Stage, container,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

container = require("../ui/container");

/*
Stage container
@note GameCore.exports.ui.Stage
*/


Stage = (function(_super) {
  __extends(Stage, _super);

  function Stage(options) {
    if (options == null) {
      options = {};
    }
    Stage.__super__.constructor.call(this, options);
    this.x = options.x || 0;
    this.y = options.y || 0;
    this.shaders = [];
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
  }

  Stage.prototype.addShader = function(shader) {
    return this.shaders.append(shader);
  };

  Stage.prototype.render = function(ctx) {
    var data, shader, _i, _len, _ref;
    this.width = this.width || ctx.canvas.width;
    this.height = this.width || ctx.canvas.height;
    if (this.shaders) {
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      Stage.__super__.render.call(this, this.ctx);
      _ref = this.shaders;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shader = _ref[_i];
        shader.process(this.ctx);
      }
      data = this.ctx.getImageData(0, 0, this.width, this.height);
      return ctx.putImageData(data, this.x, this.y);
    } else {
      return Stage.__super__.render.call(this, ctx);
    }
  };

  return Stage;

})(container);

module.exports = Stage;

/*
//File: stage.js
*/

})()
},{"../ui/container":11}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var BASELINE, Color, DEFAULT_ALIGN, DEFAULT_BASELINE, DEFAULT_COLOR, DEFAULT_FONT, Font, Text, Widget,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Widget = require("./widget");

Color = require("../utils/color");

Font = require("../utils/font");

/*
Object.defineProperty this, BASELINE
@static
*/


BASELINE = {
  /*
  Object.defineProperty this, BASELINE.TOP
  @type {String}
  @static
  */

  TOP: "top",
  /*
  Object.defineProperty this, BASELINE.HANGING
  @type {String}
  @static
  */

  HANGING: "hanging",
  /*
  Object.defineProperty this, BASELINE.MIDDLE
  @type {String}
  @static
  */

  MIDDLE: "middle",
  /*
  Object.defineProperty this, BASELINE.ALPHABETIC
  @type {String}
  @static
  */

  ALPHABETIC: "alphabetic",
  /*
  Object.defineProperty this, BASELINE.IDEOGRAPHIC
  @type {String}
  @static
  */

  IDEOGRAPHIC: "ideographic",
  /*
  Object.defineProperty this, BASELINE.BOTTOM
  @type {String}
  @static
  */

  BOTTOM: "bottom"
};

DEFAULT_FONT = new Font();

DEFAULT_COLOR = new Color("black");

DEFAULT_ALIGN = "left";

DEFAULT_BASELINE = BASELINE.TOP;

/*
Base Text widget
@note GameCore.exports.ui.Text
*/


Text = (function(_super) {
  __extends(Text, _super);

  /*
  @class Text
  @extends DisplayObject
  
  @param {Object} options any attribute may be initialized by option
  @param {String} [options.text] default - ""
  @param {String} [options.font] default - "Normal 12px Verdana"
  @param {String} [options.align] default - "left"
  @param {String} [options.baseline] default - Joy.Text.BASELINE.TOP
  @param {String} [options.color] default - #000000
  
  @constructor
  */


  function Text(options) {
    if (options == null) {
      options = {};
    }
    Text.__super__.constructor.call(this, options);
    /*
    Text to be displayed
    @attribute text
    @default ""
    @type {String}
    */

    this.text = options.text || "";
    /*
    Font family and size
    @attribute font
    @default "Normal 12px Verdana"
    @type {String}
    */

    Object.defineProperty(this, 'font', {
      get: function() {
        if (!this._font) {
          this.font = options.font || DEFAULT_FONT;
        }
        return this._font;
      },
      set: function(font) {
        this._font = font;
        return this.__measure = Text.MeasureText(this.text, this._font);
      }
    });
    /*
    Text horizontal alignment
    @attribute align
    @default "left"
    @type {String}
    */

    this.align = options.align || DEFAULT_ALIGN;
    /*
    Text vertical baseline
    @attribute baseline
    @default Joy.Text.BASELINE.TOP
    @type {String}
    */

    this.baseline = options.baseline || DEFAULT_BASELINE;
    /*
    Color of the text
    @attribute color
    @default "#000000"
    @type {String, Color}
    */

    Object.defineProperty(this, "color", {
      get: function() {
        if (!this._color) {
          this.color = options.color || DEFAULT_COLOR;
        }
        return this._color;
      },
      set: function(color) {
        this._color = typeof color === "string" ? new Color(color) : color;
        return this.alpha = this._color.a;
      },
      configurable: true
    });
    if (options.stroke) {
      this.useStroke();
    } else {
      this.useFill();
    }
    Object.defineProperty(this, "width", {
      get: function() {
        if (!this.__measure) {
          this.__measure = Text.MeasureText(this.text, this.font);
        }
        if (this.__measure) {
          return this.__measure.width;
        } else {
          return 0;
        }
      }
    });
    Object.defineProperty(this, "height", {
      get: function() {
        if (!this.__measure) {
          this.__measure = Text.MeasureText(this.text, this.font);
        }
        if (this.__measure) {
          return this.__measure.height;
        } else {
          return 0;
        }
      }
    });
  }

  /*
  @method useStroke
  */


  Text.prototype.useStroke = function() {
    this.stroke = true;
    this.fillMethod = "strokeText";
    return this.styleMethod = "strokeStyle";
  };

  /*
  @method useFill
  */


  Text.prototype.useFill = function() {
    this.stroke = false;
    this.fillMethod = "fillText";
    return this.styleMethod = "fillStyle";
  };

  Text.prototype._render = function(ctx) {
    ctx.font = this.font.toString();
    ctx.textAlign = this.align;
    ctx.textBaseline = this.baseline;
    ctx[this.styleMethod] = this.color.toString();
    ctx[this.fillMethod](this.text, 0, 0);
    return this.getMeasure(ctx);
  };

  /*
  @method getMeasure
  @return {TextMetrics} text metrics
  */


  Text.prototype.getMeasure = function(ctx) {
    var m;
    this.__measure = {};
    m = Text.MeasureText(this.text, this.font);
    this.__measure.width = m[0];
    return this.__measure.height = m[1];
  };

  Text.BASELINE = BASELINE;

  Text.MeasureText = function(text, font) {
    var div, size, str;
    str = text + ":" + font;
    if (typeof this.__measuretext_cache__ === "object" && this.__measuretext_cache__[str]) {
      return this.__measuretext_cache__[str];
    }
    div = document.createElement("DIV");
    div.innerHTML = text;
    div.style.position = "absolute";
    div.style.top = "-100px";
    div.style.left = "-100px";
    div.style.font = font.toString();
    document.body.appendChild(div);
    size = [div.offsetWidth, div.offsetHeight];
    document.body.removeChild(div);
    if (typeof this.__measuretext_cache__ !== "object") {
      this.__measuretext_cache__ = {};
    }
    this.__measuretext_cache__[str] = size;
    return size;
  };

  return Text;

})(Widget);

module.exports = Text;

/*
//File: text.js
*/

},{"../utils/color":20,"../utils/font":22,"./widget":19}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var Color, Matrix2d, Support, Triggerable, UUID, Vector2d, Widget,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

UUID = require("../math/uuid");

Triggerable = require("../core/triggerable");

Vector2d = require("../math/vector2d");

Matrix2d = require("../math/matrix2d");

Support = require("../core/support");

Color = require("../utils/color");

/*
Base renderable element

@note GameCore.exports.ui.Widget
*/


Widget = (function(_super) {
  __extends(Widget, _super);

  function Widget(options) {
    if (options == null) {
      options = {};
    }
    this.id = UUID.generateUniqueId();
    Widget.__super__.constructor.call(this, options);
    /*
    @attribute pivot
    @type {Vector2d}
    @default 0,0
    */

    this.pivot = options.pivot || new Vector2d(options.pivotX || 0, options.pivotY || 0);
    /*
    @attribute skewX
    @type {Number}
    @default 0
    */

    this.skew = options.skew || new Vector2d(options.skewX || 0, options.skewY || 0);
    /*
    @attribute scale
    @type {Vector2d}
    @default 1,1
    */

    this.scale = options.scale || new Vector2d(options.scaleX || 1, options.scaleY || 1);
    /*
    @attribute alpha
    @type {Number}
    @default 1
    */

    this.alpha = (typeof options.alpha === "undefined" ? 1 : options.alpha);
    /*
    @attribute rotation
    @type {Number}
    @default 0
    */

    this.rotation = options.rotation || 0;
    /*
    @attribute smooth
    @type {Boolean}
    @default false
    */

    this.smooth = (typeof options.smooth === "undefined" ? true : options.smooth);
    this._matrix = Matrix2d.identity.clone();
    Object.defineProperty(this, "position", {
      get: function() {
        if (!this._position) {
          this._position = new Vector2d(0, 0);
        }
        return this._position;
      },
      set: function(vector) {
        return this._position = vector.clone();
      }
    });
    Object.defineProperty(this, "x", {
      get: function() {
        return this.position.x || 0;
      },
      set: function(x) {
        return this.position.x = x;
      }
    });
    if (options.x) {
      this.x = options.x;
    }
    Object.defineProperty(this, "y", {
      get: function() {
        return this.position.y || 0;
      },
      set: function(y) {
        return this.position.y = y;
      }
    });
    if (options.y) {
      this.y = options.y;
    }
    Object.defineProperty(this, "width", {
      get: function() {
        return this._width || 0;
      },
      set: function(w) {
        return this._width = w;
      },
      configurable: true
    });
    if (options.width) {
      this.width = options.width;
    }
    Object.defineProperty(this, "height", {
      get: function() {
        return this._height || 0;
      },
      set: function(h) {
        return this._height = h;
      },
      configurable: true
    });
    if (options.height) {
      this.height = options.height;
    }
    Object.defineProperty(this, "parent", {
      get: function() {
        return this._parent || 'undefined';
      },
      set: function(parent) {
        this._parent = parent;
        return this._parent.addChild(this);
      }
    });
    if (options.parent) {
      this.parent = options.parent;
    }
    Object.defineProperty(this, "visible", {
      get: function() {
        if (this.alpha <= 0 || !this._visible) {
          return false;
        }
        return true;
      },
      set: function(visibility) {
        return this._visible = Boolean(visibility);
      }
    });
    this.visible = (options.visible ? options.visible : void 0) || true;
  }

  Widget.prototype.render = function(ctx) {
    var bit, mtx;
    if (!this.visible) {
      return;
    }
    bit = {
      "false": -1,
      "true": 1
    };
    mtx = Matrix2d.identity.appendTransform(this.position.x + this.width * (this.flipX + 0), this.position.y + this.height * (this.flipY + 0), this.scale.x * bit[!this.flipX], this.scale.y * bit[!this.flipY], this.rotation, this.skew.x, this.skew.y, this.pivot.x, this.pivot.y);
    ctx.save();
    ctx.beginPath();
    ctx.scale(this.scale.x, this.scale.y);
    ctx.translate(this.position.x, this.position.y);
    ctx.transform(mtx.m11, mtx.m12, mtx.m21, mtx.m22, mtx.dx, mtx.dy);
    ctx.rotate(0.0174532925 * this.rotation);
    ctx.setAlpha(this.alpha);
    if (this.compositeOperation) {
      ctx.globalCompositeOperation = this.compositeOperation;
    }
    ctx.setAlpha(this.alpha);
    if (this._render) {
      this._render(ctx);
    }
    ctx.scale(1 / this.scale.x, 1 / this.scale.y);
    ctx.translate(-this.position.x, -this.position.y);
    ctx.closePath();
    return ctx.restore();
  };

  return Widget;

})(Triggerable);

module.exports = Widget;

/*
//File: widget.js
*/

},{"../core/support":3,"../core/triggerable":4,"../math/matrix2d":8,"../math/uuid":9,"../math/vector2d":10,"../utils/color":20}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
Inspired by TinyColor
@see https://github.com/bgrins/TinyColor
*/

var COLOR_NAMES, COLOR_NAMES_F, CSS_INTEGER, CSS_NUMBER, CSS_UNIT, Color, Mathematic, PERMISSIVE_MATCH3, PERMISSIVE_MATCH4, bound01, convertToPercentage, flip, isOnePointZero, isPercentage, matchers, pad2, parseHex, stringInputToObject, trimLeft, trimRight;

Mathematic = require("../math/math");

/*
*/


COLOR_NAMES = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};

trimLeft = /^[\s,#]+/;

trimRight = /\s+$/;

flip = function(o) {
  var flipped, k, v;
  flipped = {};
  for (k in o) {
    v = o[k];
    flipped[v] = k;
  }
  return flipped;
};

bound01 = function(n, max) {
  var processPercent;
  if (isOnePointZero(n)) {
    n = "100%";
  }
  processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }
  return (n % max) / parseFloat(max);
};

parseHex = function(val) {
  return parseInt(val, 16);
};

isOnePointZero = function(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
};

isPercentage = function(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
};

pad2 = function(c) {
  if (c.length === 1) {
    return "0" + c;
  } else {
    return "" + c;
  }
};

convertToPercentage = function(n) {
  if (n <= 1) {
    n = (n * 100) + "%";
  }
  return n;
};

COLOR_NAMES_F = flip(COLOR_NAMES);

CSS_INTEGER = "[-\\+]?\\d+%?";

CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

matchers = {
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};

/*
Color operations

@note GameCore.exports.utils.Color
*/


Color = (function() {
  /*
  @param {String | Color} hex color string or color name or Color instance
  @param {Object} options
  */

  function Color(options) {
    var color, format, rgb;
    if (options == null) {
      options = {};
    }
    color = !options.color ? options : options.color || 'black';
    rgb = Color.inputToRGB(color);
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = options.alpha || rgb.a;
    format = options.format || rgb.format || false;
    Object.defineProperty(this, "roundA", {
      get: function() {
        return Math.round(100 * this.a) / 100;
      }
    });
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
  }

  /*
  @method toHsv
  @return {Object} {h,s,v,a}
  */


  Color.prototype.toHsv = function() {
    var hsv;
    hsv = Color.rgbToHsv(this.r, this.g, this.b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this.a
    };
  };

  /*
  @method toHsvString
  @return {String}
  */


  Color.prototype.toHsvString = function() {
    var h, hsv, s, v;
    hsv = Color.rgbToHsv(this.r, this.g, this.b);
    h = Math.round(hsv.h * 360);
    s = Math.round(hsv.s * 100);
    v = Math.round(hsv.v * 100);
    if (this.a === 1) {
      return "hsv(" + h + ", " + s + "%, " + v + "%)";
    } else {
      return "hsva(" + h + ", " + s + "%, " + v + "%, " + this.roundA + ")";
    }
  };

  /*
  @method toHsl
  @return {Object} {h,s,l,a}
  */


  Color.prototype.toHsl = function() {
    var hsl;
    hsl = Color.rgbToHsl(this.r, this.g, this.b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this.a
    };
  };

  /*
  @method toHslString
  @return {String}
  */


  Color.prototype.toHslString = function() {
    var h, hsl, l, s;
    hsl = Color.rgbToHsl(this.r, this.g, this.b);
    h = Math.round(hsl.h * 360);
    s = Math.round(hsl.s * 100);
    l = Math.round(hsl.l * 100);
    if (this.a === 1) {
      return "hsl(" + h + ", " + s + "%, " + l + "%)";
    } else {
      return "hsla(" + h + ", " + s + "%, " + l + "%, " + this.roundA + ")";
    }
  };

  /*
  @method toHex
  @param {Boolean} allow3Char defaults=false
  @return {String}
  */


  Color.prototype.toHex = function(allow3Char) {
    if (allow3Char == null) {
      allow3Char = false;
    }
    return Color.rgbToHex(this.r, this.g, this.b, allow3Char);
  };

  /*
  @method toHexString
  @param {Boolean} allow3Char defaults=false
  @return {String} # + toHex()
  */


  Color.prototype.toHexString = function(allow3Char) {
    if (allow3Char == null) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };

  /*
  @method toRgb
  @return {Object} {r,g,b,a}
  */


  Color.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };

  /*
  @method toRgbString
  @return {String}
  */


  Color.prototype.toRgbString = function() {
    if (this.a === 1) {
      return "rgb(" + Math.round(this.r) + ", " + Math.round(this.g) + ", " + Math.round(this.b) + ")";
    } else {
      return "rgba(" + Math.round(this.r) + ", " + Math.round(this.g) + ", " + Math.round(this.b) + ", " + this.roundA + ")";
    }
  };

  Color.prototype.toPercentageRgb = function() {
    return {
      r: Math.round(bound01(this.r, 255) * 100) + "%",
      g: Math.round(bound01(this.g, 255) * 100) + "%",
      b: Math.round(bound01(this.b, 255) * 100) + "%",
      a: this.a
    };
  };

  Color.prototype.toPercentageRgbString = function() {
    if (this.a === 1) {
      return "rgb(" + Math.round(bound01(this.r, 255) * 100) + "%, " + Math.round(bound01(this.g, 255) * 100) + "%, " + Math.round(bound01(this.b, 255) * 100) + "%)";
    } else {
      return "rgba(" + Math.round(bound01(this.r, 255) * 100) + "%, " + Math.round(bound01(this.g, 255) * 100) + "%, " + Math.round(bound01(this.b, 255) * 100) + "%, " + this.a + ")";
    }
  };

  Color.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    return COLOR_NAMES_F[Color.rgbToHex(this.r, this.g, this.b, true)] || false;
  };

  /*
  Outputing current color as string
  */


  Color.prototype.toString = function(format) {
    var formatSet, formatWithAlpha, formattedString, hasAlphaAndFormatNotSet;
    formatSet = !!format;
    format = format || this.format;
    formattedString = false;
    hasAlphaAndFormatNotSet = !formatSet && this.a < 1 && this.a > 0;
    formatWithAlpha = hasAlphaAndFormatNotSet && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    if (formatWithAlpha) {
      return this.toRgbString();
    } else {
      return formattedString || this.toHexString();
    }
  };

  /*
  */


  Color.prototype.readable = function(color) {
    return Color.readable(this, color);
  };

  Color.prototype.tetrad = function() {
    return Color.tetrad(this);
  };

  Color.prototype.equals = function(color) {
    return Color.equals(this, color);
  };

  Color.prototype.desaturate = function(amount) {
    var color, rgb;
    if (amount == null) {
      amount = 10;
    }
    color = Color.desaturate(this, amount);
    rgb = color.toRgb();
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    return this;
  };

  Color.prototype.clone = function() {
    return new Color(this.toString());
  };

  Color.prototype.darken = function(amount) {
    var color, rgb;
    if (amount == null) {
      amount = 10;
    }
    color = Color.darken(this, amount);
    rgb = color.toRgb();
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    return this;
  };

  Color.prototype.lighten = function(amount) {
    var color, rgb;
    if (amount == null) {
      amount = 10;
    }
    color = Color.lighten(this, amount);
    rgb = color.toRgb();
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    return this;
  };

  /*
  If input is an object, force 1 into "1.0" to handle ratios properly
  String input requires "1.0" as input, so 1 will be treated as 1
  
  Given a string or object, convert that input to RGB
  Possible string inputs:
  
  "red"
  "#f00" or "f00"
  "#ff0000" or "ff0000"
  "rgb 255 0 0" or "rgb (255, 0, 0)"
  "rgb 1.0 0 0" or "rgb (1, 0, 0)"
  "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
  "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
  "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
  "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
  "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
  
  @param {String | Color} color
  */


  Color.inputToRGB = function(color) {
    var a, format, ok, rgb;
    rgb = {
      r: 0,
      g: 0,
      b: 0
    };
    a = 1;
    ok = false;
    format = false;
    if (typeof color === "string") {
      color = stringInputToObject(color);
    }
    if (typeof color === "object") {
      if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
        rgb = Color.rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = (String(color.r).substr(-1) === "%" ? "prgb" : "rgb");
      } else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
        color.s = convertToPercentage(color.s);
        color.v = convertToPercentage(color.v);
        rgb = Color.hsvToRgb(color.h, color.s, color.v);
        ok = true;
        format = "hsv";
      } else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
        color.s = convertToPercentage(color.s);
        color.l = convertToPercentage(color.l);
        rgb = Color.hslToRgb(color.h, color.s, color.l);
        ok = true;
        format = "hsl";
      }
      if (color.hasOwnProperty("a")) {
        a = color.a;
      }
    }
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }
    return {
      ok: ok,
      format: color.format || format,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a: a
    };
  };

  /*
  Handle bounds / percentage checking to conform to CSS color spec
  <http://www.w3.org/TR/css3-color/>
  
  @method rgbToRgb
  
  @param {Integer} r in 0..255 or 0..1
  @param {Integer} g in 0..255 or 0..1
  @param {Integer} b in 0..255 or 0..1
  
  @return {Object} { r, g, b } in 0..255
  */


  Color.rgbToRgb = function(r, g, b) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b, 255) * 255
    };
  };

  /*
  Converts an RGB color value to HSL.
  
  @method rgbToHsl
  
  @param {Integer} r in 0..255 or 0..1
  @param {Integer} g in 0..255 or 0..1
  @param {Integer} b in 0..255 or 0..1
  
  @return {Object} { h, s, l } in 0..1
  */


  Color.rgbToHsl = function(r, g, b) {
    var d, h, l, max, min, s;
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    h = void 0;
    s = void 0;
    l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = (l > 0.5 ? d / (2 - max - min) : d / (max + min));
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return {
      h: h,
      s: s,
      l: l
    };
  };

  /*
  Converts an HSL color value to RGB.
  
  @method hslToRgb
  @param {Integer} h in 0..360 or 0..1
  @param {Integer} s in 0..100 or 0..1
  @param {Integer} l in 0..100 or 0..1
  @return {Object} { r, g, b } in 0..255
  */


  Color.hslToRgb = function(h, s, l) {
    var b, g, hue2rgb, p, q, r;
    hue2rgb = function(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    };
    r = void 0;
    g = void 0;
    b = void 0;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);
    if (s === 0) {
      r = g = b = l;
    } else {
      q = (l < 0.5 ? l * (1 + s) : l + s - l * s);
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  };

  /*
  Converts an RGB color value to HSV
  
  @method rgbToHsv
  @param {Integer} r in 0..255 or 0..1
  @param {Integer} g in 0..255 or 0..1
  @param {Integer} b in 0..255 or 0..1
  @return {Object} { h, s, v } in 0..1
  */


  Color.rgbToHsv = function(r, g, b) {
    var d, h, max, min, s, v;
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    h = void 0;
    s = void 0;
    v = max;
    d = max - min;
    s = (max === 0 ? 0 : d / max);
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return {
      h: h,
      s: s,
      v: v
    };
  };

  /*
  Converts an HSV color value to RGB.
  
  @method hsvToRgb
  @param {Integer} h in 0..360 or 0..1
  @param {Integer} s in 0..100 or 0..1
  @param {Integer} v in 0..100 or 0..1
  @return {Object} { r, g, b } in 0..255
  */


  Color.hsvToRgb = function(h, s, v) {
    var b, f, g, i, mod, p, q, r, t;
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    i = Math.floor(h);
    f = h - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    mod = i % 6;
    r = [v, q, p, p, t, v][mod];
    g = [t, v, v, q, p, p][mod];
    b = [p, p, t, v, v, q][mod];
    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  };

  /*
  Converts an RGB color to hex
  
  @method rgbToHex
  @param {Integer} r in 0..255
  @param {Integer} g in 0..255
  @param {Integer} b in 0..255
  @param {Boolean} allow3Char
  @return {String} 3 or 6 character hex
  */


  Color.rgbToHex = function(r, g, b, allow3Char) {
    var hex;
    if (allow3Char == null) {
      allow3Char = false;
    }
    hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
    if (allow3Char && hex[0].charAt(0) === hex[0].charAt(1) && hex[1].charAt(0) === hex[1].charAt(1) && hex[2].charAt(0) === hex[2].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join("");
  };

  return Color;

})();

/*
Permissive string parsing. Take in a number of formats, and output an object
based on detected format.
@method stringInputToObject
@param {String | Color} color
@return {Object} `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
*/


stringInputToObject = function(color) {
  var match, named;
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  named = false;
  if (COLOR_NAMES[color]) {
    color = COLOR_NAMES[color];
    named = true;
  } else if (color === "transparent") {
    ({
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    });
  }
  match = void 0;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseHex(match[1]),
      g: parseHex(match[2]),
      b: parseHex(match[3]),
      format: (named ? "name" : "hex")
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseHex(match[1] + "" + match[1]),
      g: parseHex(match[2] + "" + match[2]),
      b: parseHex(match[3] + "" + match[3]),
      format: (named ? "name" : "hex")
    };
  }
  return false;
};

Color.fromRatio = function(color, opts) {
  var i, newColor;
  if (opts == null) {
    opts = {};
  }
  if (typeof color === "object") {
    newColor = {};
    for (i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return new Color(color, opts);
};

Color.equals = function(color1, color2) {
  if (!color1 || !color2) {
    return false;
  }
  return (new Color(color1)).toRgbString() === (new Color(color2)).toRgbString();
};

Color.random = function() {
  return Color.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};

Color.desaturate = function(color, amount) {
  var hsl;
  if (amount == null) {
    amount = 10;
  }
  hsl = (new Color(color)).toHsl();
  hsl.s -= amount / 100;
  hsl.s = Mathematic.clamp01(hsl.s);
  return new Color(hsl);
};

Color.saturate = function(color, amount) {
  var hsl;
  if (amount == null) {
    amount = 10;
  }
  hsl = (new Color(color)).toHsl();
  hsl.s += amount / 100;
  hsl.s = Mathematic.clamp01(hsl.s);
  return new Color(hsl);
};

Color.greyscale = function(color) {
  return Color.desaturate(color, 100);
};

Color.lighten = function(color, amount) {
  var hsl;
  if (amount == null) {
    amount = 10;
  }
  hsl = (new Color(color)).toHsl();
  hsl.l += amount / 100;
  hsl.l = Mathematic.clamp01(hsl.l);
  return new Color(hsl);
};

Color.darken = function(color, amount) {
  var hsl;
  if (amount == null) {
    amount = 10;
  }
  hsl = (new Color(color)).toHsl();
  hsl.l -= amount / 100;
  hsl.l = Mathematic.clamp01(hsl.l);
  return new Color(hsl);
};

Color.complement = function(color) {
  var hsl;
  hsl = (new Color(color)).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return new Color(hsl);
};

Color.triad = function(color) {
  var h, hsl;
  hsl = (new Color(color)).toHsl();
  h = hsl.h;
  return [
    new Color(color), new Color({
      h: (h + 120) % 360,
      s: hsl.s,
      l: hsl.l
    }), new Color({
      h: (h + 240) % 360,
      s: hsl.s,
      l: hsl.l
    })
  ];
};

Color.tetrad = function(color) {
  var h, hsl;
  hsl = (new Color(color)).toHsl();
  h = hsl.h;
  return [
    new Color(color), new Color({
      h: (h + 90) % 360,
      s: hsl.s,
      l: hsl.l
    }), new Color({
      h: (h + 180) % 360,
      s: hsl.s,
      l: hsl.l
    }), new Color({
      h: (h + 270) % 360,
      s: hsl.s,
      l: hsl.l
    })
  ];
};

Color.splitcomplement = function(color) {
  var h, hsl;
  hsl = (new Color(color)).toHsl();
  h = hsl.h;
  return [
    new Color(color), new Color({
      h: (h + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), new Color({
      h: (h + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })
  ];
};

Color.analogous = function(color, results, slices) {
  var hsl, part, ret;
  if (results == null) {
    results = 6;
  }
  if (slices == null) {
    slices = 30;
  }
  hsl = (new Color(color)).toHsl();
  part = 360 / slices;
  ret = [new Color(color)];
  hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360;
  while (--results) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(new Color(hsl));
  }
  return ret;
};

Color.monochromatic = function(color, results) {
  var h, hsv, modification, ret, s, v;
  if (results == null) {
    results = 6;
  }
  hsv = (new Color(color)).toHsv();
  h = hsv.h;
  s = hsv.s;
  v = hsv.v;
  ret = [];
  modification = 1 / results;
  while (results--) {
    ret.push(Color({
      h: h,
      s: s,
      v: v
    }));
    v = (v + modification) % 1;
  }
  return ret;
};

Color.readability = function(color1, color2) {
  var a, b, brightnessA, brightnessB, colorDiff;
  a = (new Color(color1)).toRgb();
  b = (new Color(color2)).toRgb();
  brightnessA = (a.r * 299 + a.g * 587 + a.b * 114) / 1000;
  brightnessB = (b.r * 299 + b.g * 587 + b.b * 114) / 1000;
  colorDiff = Math.max(a.r, b.r) - Math.min(a.r, b.r) + Math.max(a.g, b.g) - Math.min(a.g, b.g) + Math.max(a.b, b.b) - Math.min(a.b, b.b);
  return {
    brightness: Math.abs(brightnessA - brightnessB),
    color: colorDiff
  };
};

Color.readable = function(color1, color2) {
  var readability;
  readability = Color.readability(color1, color2);
  return readability.brightness > 125 && readability.color > 500;
};

Color.mostReadable = function(baseColor, colorList) {
  var bestColor, bestIsReadable, bestScore, i, readability, readable, score;
  bestColor = null;
  bestScore = 0;
  bestIsReadable = false;
  i = 0;
  while (i < colorList.length) {
    readability = Color.readability(baseColor, colorList[i]);
    readable = readability.brightness > 125 && readability.color > 500;
    score = 3 * (readability.brightness / 125) + (readability.color / 500);
    if ((readable && !bestIsReadable) || (readable && bestIsReadable && score > bestScore) || ((!readable) && (!bestIsReadable) && score > bestScore)) {
      bestIsReadable = readable;
      bestScore = score;
      bestColor = new Color(colorList[i]);
    }
    i++;
  }
  return bestColor;
};

module.exports = Color;

/*
//File: color.js
*/

},{"../math/math":7}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
module.exports = {
  Color: require("./color"),
  Font: require("./font")
};

/*
//File: exports.js
*/

},{"./color":20,"./font":22}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
Inspired by Font.js by  Mike "Pomax" Kamermans
@see http://github.com/Pomax/Font.js
*/

var FONT_CACHE, FONT_DEFAULTS, Font, Mathmetics, Triggerable, chr, chr16, dechex, fword, ulong, ushort,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Mathmetics = require("../math/math");

Triggerable = require("../core/triggerable");

FONT_CACHE = {};

FONT_DEFAULTS = {
  fontFamily: 'Verdena',
  fontSize: 12
};

chr = function(val) {
  return String.fromCharCode(val);
};

chr16 = function(val) {
  var b1, b2;
  if (val < 256) {
    return chr(0) + chr(val);
  }
  b1 = val >> 8;
  b2 = val & 0xFF;
  return chr(b1) + chr(b2);
};

dechex = function(val) {
  if (val < 0) {
    val = 0xFFFFFFFF + val + 1;
  }
  return parseInt(val, 10).toString(16);
};

ushort = function(b1, b2) {
  return 256 * b1 + b2;
};

fword = function(b1, b2) {
  var negative, val;
  negative = b1 >> 7 === 1;
  val = void 0;
  b1 = b1 & 0x7F;
  val = 256 * b1 + b2;
  if (!negative) {
    return val;
  }
  return val - 0x8000;
};

ulong = function(b1, b2, b3, b4) {
  return 16777216 * b1 + 65536 * b2 + 256 * b3 + b4;
};

/*
Font manipulations and measurement

@note GameCore.exports.Utils.Font
*/


Font = (function(_super) {
  __extends(Font, _super);

  function Font(options) {
    if (options == null) {
      options = {};
    }
    this.url = options.url || options.src || "";
    this.fontFamily = this.url ? options.fontFamily || "font" + Mathmetics.randomInt(0, 999999) : FONT_DEFAULTS.fontFamily;
    this.fontSize = options.fontSize || options.size || FONT_DEFAULTS.fontSize;
    this.format = options.format || "";
    this.data = options.data || "";
    this.base64 = "AAEAAAAKAIAAAwAgT1MvMgAAAAAAAACsAAAAWGNtYXAA" + "AAAAAAABBAAAACxnbHlmAAAAAAAAATAAAAAQaGVhZAAAA" + "AAAAAFAAAAAOGhoZWEAAAAAAAABeAAAACRobXR4AAAAAA" + "AAAZwAAAAIbG9jYQAAAAAAAAGkAAAACG1heHAAAAAAAAA" + "BrAAAACBuYW1lAAAAAAAAAcwAAAAgcG9zdAAAAAAAAAHs" + "AAAAEAAEAAEAZAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAABAAMAAQA" + "AAAwABAAgAAAABAAEAAEAAABB//8AAABB////wAABAAAA" + "AAABAAAAAAAAAAAAAAAAMQAAAQAAAAAAAAAAAABfDzz1A" + "AAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAEAAg" + "AAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAQAAAAAAAAAAAAAAAAAIAAAAAQAAAAIAAQAB" + "AAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAIAHgADAAEEC" + "QABAAAAAAADAAEECQACAAIAAAAAAAEAAAAAAAAAAAAAAA" + "AAAA==";
    /*
    these metrics represent the font-indicated values,
    not the values pertaining to text as it is rendered
    on the page (use fontmetrics.js for this instead).
    */

    this.metrics = {
      quadsize: 0,
      leading: 0,
      ascent: 0,
      descent: 0,
      weightclass: 400
    };
    Object.defineProperty(this, "systemfont", {
      get: function() {
        if (this._systemfont) {
          return this._systemfont;
        } else {
          if (this.url) {
            return false;
          } else {
            return true;
          }
        }
      },
      set: function(oreally) {
        return this._systemfont = oreally;
      }
    });
    this.loaded = false;
    this.canvas = false;
    this.context = false;
    this.styleNode = false;
    /*
    we want Font to do the same thing Image does when
    we set the "src" property value, so we use the
    Object.defineProperty function to bind a setter
    that does more than just bind values.
    */

    Object.defineProperty(this, "src", {
      get: function() {
        return this.url;
      },
      set: function(url) {
        this.url = url;
        return this.loadFont();
      }
    });
    if (this.url) {
      this.loadFont();
    }
  }

  /*
  This function gets called once the font is done
  loading, its metrics have been determined, and it
  has been parsed for use on-page. By default, this
  function does nothing, and users can bind their
  own handler function.
  */


  Font.prototype.onload = function() {};

  /*
  This function gets called when there is a problem
  loading the font.
  */


  Font.prototype.onerror = function() {};

  /*
  validation function to see if the zero-width styled
  text is no longer zero-width. If this is true, the
  font is properly done loading. If this is false, the
  function calls itself via a timeout
  */


  Font.prototype.validate = function(target, zero, mark, font, timeout) {
    var computedStyle, width;
    if (timeout !== false && timeout < 0) {
      this.onerror();
      throw new Error("Requested system font '" + this.fontFamily + "' could not be loaded (it may not be installed).");
      return;
    }
    computedStyle = document.defaultView.getComputedStyle(target, "");
    width = computedStyle.getPropertyValue("width").replace("px", "");
    if (width > 0) {
      document.head.removeChild(zero);
      document.body.removeChild(target);
      this.loaded = true;
      return this.onload();
    } else {
      return setTimeout((function() {
        return font.validate(target, zero, mark, font, (timeout === false ? false : timeout - 50));
      }), 50);
    }
  };

  /*
  This gets called when the file is done downloading.
  */


  Font.prototype.ondownloaded = function() {
    var cff, data, error, instance, isCFF, isTTF, isWOFF, printChar, ttf, version, woff;
    instance = this;
    error = function(msg) {
      return instance.onerror(msg);
    };
    ttf = chr(0) + chr(1) + chr(0) + chr(0);
    cff = 'OTTO';
    woff = 'wOFF';
    data = this.data;
    version = chr(data[0]) + chr(data[1]) + chr(data[2]) + chr(data[3]);
    isTTF = version === ttf;
    isCFF = (isTTF ? false : version === cff);
    isWOFF = (isCFF || isTTF ? false : version === woff);
    if (isTTF) {
      this.format = "truetype";
    } else if (isCFF) {
      this.format = "opentype";
    } else if (isWOFF) {
      this.format = "woff";
    } else {
      throw new Error("Error: file at " + this.url + " cannot be interpreted as OpenType font.");
      return;
    }
    printChar = this.format === 'truetype' || this.format === 'opentype' ? this._verifyTTForOTF(data) : 'A';
    return this.bootstrapValidation(printChar);
  };

  Font.prototype._verifyTTForOTF = function(data) {
    var checkTableError, cmap314, delta, e, encodingID, encodingRecord, end, endChar, i, newhex, numTables, offset, platformID, printChar, printable, ptr, rptr, segCount, tag, tagStart, tags, unitsPerEm, version;
    numTables = ushort(data[4], data[5]);
    tagStart = 12;
    ptr = void 0;
    end = tagStart + 16 * numTables;
    tags = {};
    tag = void 0;
    ptr = tagStart;
    while (ptr < end) {
      tag = chr(data[ptr]) + chr(data[ptr + 1]) + chr(data[ptr + 2]) + chr(data[ptr + 3]);
      tags[tag] = {
        name: tag,
        checksum: ulong(data[ptr + 4], data[ptr + 5], data[ptr + 6], data[ptr + 7]),
        offset: ulong(data[ptr + 8], data[ptr + 9], data[ptr + 10], data[ptr + 11]),
        length: ulong(data[ptr + 12], data[ptr + 13], data[ptr + 14], data[ptr + 15])
      };
      ptr += 16;
    }
    checkTableError = function(tag) {
      if (!tags[tag]) {
        throw new Error("Error: font is missing the required OpenType '" + tag + "' table.");
        return false;
      }
      return tag;
    };
    tag = checkTableError("head");
    if (tag === false) {
      return;
    }
    ptr = tags[tag].offset;
    tags[tag].version = "" + data[ptr] + data[ptr + 1] + data[ptr + 2] + data[ptr + 3];
    unitsPerEm = ushort(data[ptr + 18], data[ptr + 19]);
    this.metrics.quadsize = unitsPerEm;
    tag = checkTableError("hhea");
    if (tag === false) {
      return;
    }
    ptr = tags[tag].offset;
    tags[tag].version = "" + data[ptr] + data[ptr + 1] + data[ptr + 2] + data[ptr + 3];
    this.metrics.ascent = fword(data[ptr + 4], data[ptr + 5]) / unitsPerEm;
    this.metrics.descent = fword(data[ptr + 6], data[ptr + 7]) / unitsPerEm;
    this.metrics.leading = fword(data[ptr + 8], data[ptr + 9]) / unitsPerEm;
    tag = checkTableError("OS/2");
    if (tag === false) {
      return;
    }
    ptr = tags[tag].offset;
    tags[tag].version = "" + data[ptr] + data[ptr + 1];
    this.metrics.weightclass = ushort(data[ptr + 4], data[ptr + 5]);
    tag = checkTableError("cmap");
    if (tag === false) {
      return;
    }
    ptr = tags[tag].offset;
    tags[tag].version = "" + data[ptr] + data[ptr + 1];
    numTables = ushort(data[ptr + 2], data[ptr + 3]);
    encodingRecord = void 0;
    rptr = void 0;
    platformID = void 0;
    encodingID = void 0;
    offset = void 0;
    cmap314 = false;
    encodingRecord = 0;
    while (encodingRecord < numTables) {
      rptr = ptr + 4 + encodingRecord * 8;
      platformID = ushort(data[rptr], data[rptr + 1]);
      encodingID = ushort(data[rptr + 2], data[rptr + 3]);
      offset = ulong(data[rptr + 4], data[rptr + 5], data[rptr + 6], data[rptr + 7]);
      if (platformID === 3 && encodingID === 1) {
        cmap314 = offset;
      }
      encodingRecord++;
    }
    printChar = "A";
    if (cmap314 !== false) {
      ptr += cmap314;
      version = ushort(data[ptr], data[ptr + 1]);
      if (version === 4) {
        segCount = ushort(data[ptr + 6], data[ptr + 7]) / 2;
        printable = function(chr) {
          return [0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x0020, 0x0085, 0x00A0, 0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x2028, 0x2029, 0x202F, 0x205F, 0x3000].indexOf(chr) === -1;
        };
        i = ptr + 14;
        e = ptr + 14 + 2 * segCount;
        endChar = false;
        while (i < e) {
          endChar = ushort(data[i], data[i + 1]);
          if (printable(endChar)) {
            break;
          }
          endChar = false;
          i += 2;
        }
        if (endChar !== false) {
          printChar = String.fromCharCode(endChar);
          delta = -(endChar - 1) + 65536;
          newhex = btoa(chr(0) + chr16(endChar) + chr16(0xFFFF) + chr16(0) + chr16(endChar) + chr16(0xFFFF) + chr16(delta) + chr16(1));
          this.base64 = this.base64.substring(0, 380) + newhex + this.base64.substring(380 + newhex.length);
        }
      }
    }
    return printChar;
  };

  Font.prototype.bootstrapValidation = function(printChar, timeout) {
    var canvas, context, delayedValidate, local, para, quad, realfont, tfName, zerowidth;
    if (timeout == null) {
      timeout = false;
    }
    tfName = this.fontFamily + " testfont";
    zerowidth = document.createElement("style");
    zerowidth.setAttribute("type", "text/css");
    zerowidth.innerHTML = "@font-face {\n" + " font-family: '" + tfName + "';\n" + " src: url('data:application/x-font-ttf;base64," + this.base64 + "')\n" + " format('truetype');}";
    document.head.appendChild(zerowidth);
    realfont = false;
    if (!this.systemfont) {
      realfont = this.toStyleNode();
      document.head.appendChild(realfont);
    }
    para = document.createElement("p");
    para.style.cssText = "position: absolute; top: 0; left: 0; opacity: 0;";
    para.style.fontFamily = "'" + this.fontFamily + "', '" + tfName + "'";
    para.innerHTML = printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar + printChar;
    document.body.appendChild(para);
    if (!document.defaultView.getComputedStyle) {
      this.onload();
      return error("Error: document.defaultView.getComputedStyle is not supported by this browser.\n" + "Consequently, Font.onload() cannot be trusted.");
    } else {
      quad = (this.systemfont ? 1000 : this.metrics.quadsize);
      canvas = document.createElement("canvas");
      canvas.width = quad;
      canvas.height = quad;
      this.canvas = canvas;
      context = canvas.getContext("2d");
      context.font = "1em '" + this.fontFamily + "'";
      context.fillStyle = "white";
      context.fillRect(-1, -1, quad + 2, quad + 2);
      context.fillStyle = "black";
      context.fillText("test text", 50, quad / 2);
      this.context = context;
      local = this;
      delayedValidate = function() {
        return local.validate(para, zerowidth, realfont, local, timeout);
      };
      return setTimeout(delayedValidate, 50);
    }
  };

  /*
  We take a different path for System fonts, because
  we cannot inspect the actual byte code.
  */


  Font.prototype.processSystemFont = function() {
    this.systemfont = true;
    this.metrics = false;
    return this.bootstrapValidation("A", 1000);
  };

  /*
  This gets called when font.src is set, (the binding
  for which is at the end of this file).
  */


  Font.prototype.loadFont = function() {
    var font, xhr;
    font = this;
    if (this.url.indexOf(".") === -1) {
      setTimeout((function() {
        return font.processSystemFont();
      }), 10);
      return;
    }
    xhr = new XMLHttpRequest();
    xhr.open("GET", font.url, true);
    xhr.responseType = "arraybuffer";
    xhr.onreadystatechange = function(evt) {
      var arrayBuffer;
      if (xhr.readyState !== 4) {
        return;
      }
      if (xhr.status !== 200) {
        throw new Error("Can't load from " + this.url + ". Please, verify source urls.");
      }
      arrayBuffer = xhr.response;
      if (arrayBuffer) {
        font.data = new Uint8Array(arrayBuffer);
        return font.ondownloaded();
      } else {
        return font.onerror("Error downloading font resource from " + font.url);
      }
    };
    return xhr.send(null);
  };

  /*
  Get the DOM node associated with this Font
  object, for page-injection.
  */


  Font.prototype.toStyleNode = function() {
    var styletext;
    if (this.styleNode) {
      return this.styleNode;
    }
    this.styleNode = document.createElement("style");
    this.styleNode.type = "text/css";
    styletext = "@font-face {\n";
    styletext += " font-family: '" + this.fontFamily + "';\n";
    styletext += " src: local('" + this.fontFamily + "'), url('" + this.url + "') format('" + this.format + "');\n";
    styletext += "}";
    this.styleNode.innerHTML = styletext;
    return this.styleNode;
  };

  /*
  Measure a specific string of text, given this font.
  If the text is too wide for our preallocated canvas,
  it will be chopped up and the segments measured
  separately.
  */


  Font.prototype.measureText = function(textString) {
    var i, metrics, minSegments, segmentLength, segments;
    if (!(this.loaded && !this.systemfont)) {
      throw new Error("measureText() was called while the font was not yet loaded");
      return false;
    }
    this.context.font = this.toString();
    metrics = this.context.measureText(textString);
    metrics.fontsize = this.fontSize;
    metrics.ascent = 0;
    metrics.descent = 0;
    metrics.bounds = {
      minx: 0,
      maxx: metrics.width,
      miny: 0,
      maxy: 0
    };
    metrics.height = 0;
    segments = [];
    minSegments = metrics.width / this.metrics.quadsize;
    if (minSegments <= 1) {
      segments.push(textString);
    } else {
      segments.push(textString);
    }
    segmentLength = segments.length;
    i = void 0;
    i = 0;
    while (i < segmentLength) {
      this.measureSegment(segments[i], metrics);
      i++;
    }
    return metrics;
  };

  /*
  Measure a section of text, given this font, that is
  guaranteed to fit on our preallocated canvas.
  */


  Font.prototype.measureSegment = function(textSegment, metrics) {
    var ascent, baseline, canvas, ctx, descent, getCSSValue, h, i, j, leadDiv, leadDivHeight, len, maxx, mid, minx, numLines, padding, pixelData, quad, scanheight, scanwidth, step, w, w4, x_offset, xpos, y_offset;
    getCSSValue = function(element, property) {
      return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
    };
    i = void 0;
    leadDiv = document.createElement("div");
    leadDiv.style.position = "absolute";
    leadDiv.style.opacity = 0;
    leadDiv.style.font = this.toString();
    numLines = 10;
    leadDiv.innerHTML = textSegment;
    i = 1;
    while (i < numLines) {
      leadDiv.innerHTML += "<br/>" + textSegment;
      i++;
    }
    document.body.appendChild(leadDiv);
    metrics.leading = 1.2 * this.fontSize;
    leadDivHeight = getCSSValue(leadDiv, "height");
    leadDivHeight = leadDivHeight.replace("px", "");
    if (leadDivHeight >= this.fontSize * numLines) {
      metrics.leading = (leadDivHeight / numLines) | 0;
    }
    document.body.removeChild(leadDiv);
    if (/^\s*$/.test(textSegment)) {
      return metrics;
    }
    canvas = this.canvas;
    ctx = this.context;
    quad = (this.systemfont ? 1000 : this.metrics.quadsize);
    w = quad;
    h = quad;
    baseline = quad / 2;
    padding = 50;
    xpos = (quad - metrics.width) / 2;
    if (xpos !== (xpos | 0)) {
      xpos = xpos | 0;
    }
    ctx.fillStyle = "white";
    ctx.fillRect(-padding, -padding, w + 2 * padding, h + 2 * padding);
    ctx.fillStyle = "black";
    ctx.fillText(textSegment, xpos, baseline);
    scanwidth = (metrics.width + padding) | 0;
    scanheight = 4 * this.fontSize;
    x_offset = xpos - padding / 2;
    y_offset = baseline - scanheight / 2;
    pixelData = ctx.getImageData(x_offset, y_offset, scanwidth, scanheight).data;
    i = 0;
    j = 0;
    w4 = scanwidth * 4;
    len = pixelData.length;
    mid = scanheight / 2;
    while (++i < len && pixelData[i] === 255) {
      continue;
    }
    ascent = (i / w4) | 0;
    i = len - 1;
    while (--i > 0 && pixelData[i] === 255) {
      continue;
    }
    descent = (i / w4) | 0;
    i = 0;
    j = 0;
    while (j < scanwidth && pixelData[i] === 255) {
      i += w4;
      if (i >= len) {
        j++;
        i = (i - len) + 4;
      }
    }
    minx = j;
    step = 1;
    i = len - 3;
    j = 0;
    while (j < scanwidth && pixelData[i] === 255) {
      i -= w4;
      if (i < 0) {
        j++;
        i = (len - 3) - (step++) * 4;
      }
    }
    maxx = scanwidth - j;
    metrics.ascent = mid - ascent;
    metrics.descent = descent - mid;
    metrics.bounds = {
      minx: minx - (padding / 2),
      maxx: maxx - (padding / 2),
      miny: -metrics.descent,
      maxy: metrics.ascent
    };
    metrics.height = 1 + (descent - ascent);
    return metrics;
  };

  Font.prototype.toString = function() {
    return "" + this.fontSize + "px '" + this.fontFamily + "'";
  };

  return Font;

})(Triggerable);

module.exports = Font;

/*
//File: font.js
*/

},{"../core/triggerable":4,"../math/math":7}]},{},[5])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC9jb3JlL2NvbnRleHQvMmQuanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC9jb3JlL2NvcmUuanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC9jb3JlL3N1cHBvcnQuanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC9jb3JlL3RyaWdnZXJhYmxlLmpzIiwiL1VzZXJzL2FsZXgvQ29kaW5nL0dhbWVDb3JlLy50bXAvZ2FtZWNvcmUuanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC9tYXRoL2V4cG9ydHMuanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC9tYXRoL21hdGguanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC9tYXRoL21hdHJpeDJkLmpzIiwiL1VzZXJzL2FsZXgvQ29kaW5nL0dhbWVDb3JlLy50bXAvbWF0aC91dWlkLmpzIiwiL1VzZXJzL2FsZXgvQ29kaW5nL0dhbWVDb3JlLy50bXAvbWF0aC92ZWN0b3IyZC5qcyIsIi9Vc2Vycy9hbGV4L0NvZGluZy9HYW1lQ29yZS8udG1wL3VpL2NvbnRhaW5lci5qcyIsIi9Vc2Vycy9hbGV4L0NvZGluZy9HYW1lQ29yZS8udG1wL3VpL2V4cG9ydHMuanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC91aS9nZW9tZXRyeS9jaXJjbGUuanMiLCIvVXNlcnMvYWxleC9Db2RpbmcvR2FtZUNvcmUvLnRtcC91aS9nZW9tZXRyeS9leHBvcnRzLmpzIiwiL1VzZXJzL2FsZXgvQ29kaW5nL0dhbWVDb3JlLy50bXAvdWkvZ2VvbWV0cnkvcmVjdC5qcyIsIi9Vc2Vycy9hbGV4L0NvZGluZy9HYW1lQ29yZS8udG1wL3VpL3Nwcml0ZS5qcyIsIi9Vc2Vycy9hbGV4L0NvZGluZy9HYW1lQ29yZS8udG1wL3VpL3N0YWdlLmpzIiwiL1VzZXJzL2FsZXgvQ29kaW5nL0dhbWVDb3JlLy50bXAvdWkvdGV4dC5qcyIsIi9Vc2Vycy9hbGV4L0NvZGluZy9HYW1lQ29yZS8udG1wL3VpL3dpZGdldC5qcyIsIi9Vc2Vycy9hbGV4L0NvZGluZy9HYW1lQ29yZS8udG1wL3V0aWxzL2NvbG9yLmpzIiwiL1VzZXJzL2FsZXgvQ29kaW5nL0dhbWVDb3JlLy50bXAvdXRpbHMvZXhwb3J0cy5qcyIsIi9Vc2Vycy9hbGV4L0NvZGluZy9HYW1lQ29yZS8udG1wL3V0aWxzL2ZvbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xudmFyIENvbnRleHQyZDtcblxuQ29udGV4dDJkID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBDb250ZXh0MmQob3B0aW9ucykge1xuICAgIHRoaXMuc2V0Q2FudmFzKG9wdGlvbnMuY2FudmFzKTtcbiAgfVxuXG4gIENvbnRleHQyZC5wcm90b3R5cGUuc2V0Q2FudmFzID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENvbnRleHQyZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDb250ZXh0MmQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGxheWVycykge1xuICAgIHZhciBsYXllciwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgIGlmIChsYXllcnMgPT0gbnVsbCkge1xuICAgICAgbGF5ZXJzID0gW107XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gbGF5ZXJzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBsYXllciA9IGxheWVyc1tfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKGxheWVyLnJlbmRlcih0aGlzLmN0eCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRleHQyZDtcblxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0MmQ7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD0yZC5tYXBcbiovXG4iLCIoZnVuY3Rpb24oKXsvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG52YXIgR2FtZUNvcmUsIFN0YWdlLCBUcmlnZ2VyYWJsZSwgVVVJRCwgY29udGV4dDJkLCBzdXBwb3J0LFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbmNvbnRleHQyZCA9IHJlcXVpcmUoXCIuL2NvbnRleHQvMmRcIik7XG5cbnN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xuXG5UcmlnZ2VyYWJsZSA9IHJlcXVpcmUoXCIuL3RyaWdnZXJhYmxlXCIpO1xuXG5VVUlEID0gcmVxdWlyZShcIi4uL21hdGgvdXVpZFwiKTtcblxuU3RhZ2UgPSByZXF1aXJlKFwiLi4vdWkvc3RhZ2VcIik7XG5cbi8qXG5HYW1lIENvcmUgYmFzZSBjbGFzc1xuXG5AcHJvcGVydHkge1N0YWdlfSBzdGFnZVxuQHByb3BlcnR5IHtCb29sZWFufSBmdWxsV2luZG93U2l6ZVxuQHByb3BlcnR5IHtCb29sZWFufSBwYXVzZWRcbkBwcm9wZXJ0eSB7Q29udGV4dH0gY29udGV4dFxuQHByb3BlcnR5IHtJbnR9IHdpZHRoXG5AcHJvcGVydHkge0ludH0gaGVpZ3RoXG5AcHJvcGVydHkge0RPTUVsZW1lbnR9IHJlbmRlcmVyXG5cbkBleGFtcGxlIEhvdyB0byBjcmVhdGUgYW4gZ2FtZSBjb3JlIFxuICAgIGdjID0gbmV3IEdhbWVDb3JlKCkgIyBDcmVhdGluZyBjb3JlXG4gICAgZ2MucmVuZGVyZXIgPSBkb2N1bWVudC5ib2R5ICMgQXBwZW5kcyBuZXcgY2FudmFzIGVsZW1lbnQgdG8gZG9jdW1lbnRzIGJvZHlcblxuQGV4YW1wbGUgTWFraW5nIGNhbnZhcyBmdWxsLXNpemVkXG4gICAgZ2MgPSBuZXcgR2FtZUNvcmUoKSAjIENyZWF0aW5nIGNvcmVcbiAgICBnYy5mdWxsV2luZG93U2l6ZSA9IHRydWVcbiovXG5cblxuR2FtZUNvcmUgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhHYW1lQ29yZSwgX3N1cGVyKTtcblxuICAvKlxuICBHYW1lQ29yZSBpbnN0YW5jZWMgYXJjaGl2ZVxuICAqL1xuXG5cbiAgR2FtZUNvcmUuY29yZXMgPSB7fTtcblxuICAvKlxuICBTdGFydCB5b3VyIGFwcGxpY2F0aW9uIGZyb20gaGVyZS5cbiAgXG4gIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICovXG5cblxuICBmdW5jdGlvbiBHYW1lQ29yZShvcHRpb25zKSB7XG4gICAgdmFyIGVycm9yLCBfaSwgX2xlbiwgX3JlZjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgR2FtZUNvcmUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAvKlxuICAgIEluIHRoZSBmaXJzdCBjYXNlIHdlIG5lZWQgdG8gZ2VuZXJhdGUgaWQgZm9yIG5ldyBpbnN0YW5jZSwgaWYgaXQgbm90XG4gICAgIHByZXNlbnQgaW4gb3B0aW9ucy5cbiAgICAqL1xuXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZCB8fCBVVUlELmdlbmVyYXRlVW5pcXVlSWQoKTtcbiAgICAvKlxuICAgIENoZWNpbmcgZm9yIHJ1bnRpbWUgZXJyb3JzXG4gICAgKi9cblxuICAgIGlmIChzdXBwb3J0LkVSUk9SUykge1xuICAgICAgX3JlZiA9IHN1cHBvcnQuRVJST1JTO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVycm9yID0gX3JlZltfaV07XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIFNldHRpbmcgdXAgYSBjYW52YXMuXG4gICAgSWYgY2FudmFzIGRvZXNuJ3QgcHJlc2VudCBpbiBvcHRpb25zIHRoZW4gY3JlYXRlIGl0LlxuICAgICovXG5cbiAgICB0aGlzLm9wdGlvbnMuY2FudmFzID0gdGhpcy5vcHRpb25zLmNhbnZhcyB8fCB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgIC8qXG4gICAgUmVnaXN0cmF0aW5nIEdhbWVDb3JlIGluc3RhbmNlIGluIGNhbnZhcyBhbmcgR2FtZUNvcmUgZ2xvYmFsLlxuICAgICovXG5cbiAgICB0aGlzLm9wdGlvbnMuY2FudmFzLmNvcmUgPSB0aGlzO1xuICAgIEdhbWVDb3JlLmNvcmVzW3RoaXMuaWRdID0gdGhpcztcbiAgICAvKlxuICAgIFNldHRpbmcgdXAgZnJhbWVyYXRlXG4gICAgKi9cblxuICAgIHRoaXMuc2V0RnJhbWVyYXRlKCk7XG4gICAgLypcbiAgICBTdGFnZXMgbWFwXG4gICAgKi9cblxuICAgIHRoaXMuX3N0YWdlcyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWdlXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFnZTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRfc3RhZ2VfaWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhZ2VzW3RoaXMuX2N1cnJlbnRfc3RhZ2VfaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWdlID0gbmV3IFN0YWdlO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRfc3RhZ2VfaWQgPSBzdGFnZS5pZDtcbiAgICAgICAgICB0aGlzLmFkZFN0YWdlKHN0YWdlKTtcbiAgICAgICAgICByZXR1cm4gc3RhZ2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHN0YWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhZ2VzW3N0YWdlLmlkXSkge1xuICAgICAgICAgIHRoaXMuYWRkU3RhZ2Uoc3RhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRfc3RhZ2VfaWQgPSBzdGFnZS5pZDtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignc3RhZ2VfY2hhbmdlZCcsIHN0YWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKlxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdWxsV2luZG93U2l6ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5fdGhlX2Z1bGxzY3JlZW5fbm93O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oYikge1xuICAgICAgICBpZiAoYiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX2Z1bGxXaW5kb3dTaXplX3Jlc2l6ZXIpO1xuICAgICAgICAgIHRoaXMuX2luX3RoZV9mdWxsc2NyZWVuX25vdyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U2l6ZShkb2N1bWVudC53aWR0aCwgZG9jdW1lbnQuaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9mdWxsV2luZG93U2l6ZV9yZXNpemVyKTtcbiAgICAgICAgICB0aGlzLl9pbl90aGVfZnVsbHNjcmVlbl9ub3cgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTaXplKHRoaXMub3B0aW9ucy53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZ1bGxXaW5kb3dTaXplID0gdGhpcy5vcHRpb25zLmZ1bGxXaW5kb3dTaXplO1xuICAgIC8qXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2FudmFzLndpZHRoO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNhbnZhcy5oZWlnaHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5mdWxsV2luZG93U2l6ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gd2luZG93LndpZHRoO1xuICAgICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IHdpbmRvdy5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuc2V0U2l6ZSh0aGlzLm9wdGlvbnMud2lkdGgsIHRoaXMub3B0aW9ucy5oZWlnaHQpO1xuICAgIC8qXG4gICAgQ29udGV4dCBlbGVtZW50LlxuICAgIEN1cnJlbnRseSBzdXBwb3J0IG9ubHkgQ29udGV4dDJkXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRleHRcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dCA9IG5ldyBjb250ZXh0MmQoe1xuICAgICAgICAgICAgY2FudmFzOiB0aGlzLm9wdGlvbnMuY2FudmFzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLypcbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF1c2VkXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzZWQgfHwgZmFsc2U7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihwYXVzZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdXNlZCA9IHBhdXNlZCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKlxuICAgIFJlbmRlcmVyIGVsZW1lbnQuXG4gICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlbmRlcmVyXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRfbm9kZSB8fCAndW5kZWZpbmVkJztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLnRhZ05hbWUpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbiByZW5kZXIgb25seSBvbiBkb2N1bWVudCBlbGVtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMub3B0aW9ucy5jYW52YXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50X25vZGUgPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX29uRW50ZXJGcmFtZSgpO1xuICB9XG5cbiAgLypcbiAgKi9cblxuXG4gIEdhbWVDb3JlLnByb3RvdHlwZS5hZGRTdGFnZSA9IGZ1bmN0aW9uKHN0YWdlLCBzZXRDdXJyZW50KSB7XG4gICAgaWYgKHNldEN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGFnZSA9IHN0YWdlIHx8IG5ldyBTdGFnZTtcbiAgICB0aGlzLl9zdGFnZXNbc3RhZ2UuaWRdID0gc3RhZ2U7XG4gICAgaWYgKHNldEN1cnJlbnQpIHtcbiAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZS5pZDtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdzdGFnZV9hZGRlZCcsIHN0YWdlKTtcbiAgICByZXR1cm4gc3RhZ2U7XG4gIH07XG5cbiAgLypcbiAgU3dpdGNoIHBhdXNlIHN0YXRlXG4gICovXG5cblxuICBHYW1lQ29yZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBhdXNlZCA9ICF0aGlzLnBhdXNlZDtcbiAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ3BhdXNlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCd1bnBhdXNlZCcpO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICBTZXQncyBmcmFtZXJhdGUuIE5vdCB1c2FibGUgYXQgdGhlIG1vbWVudC4uLlxuICBAcGFyYW0ge0ludH0gZnJhbWVyYXRlXG4gIEBtZXRob2Qgc2V0RnJhbWVyYXRlXG4gICovXG5cblxuICBHYW1lQ29yZS5wcm90b3R5cGUuc2V0RnJhbWVyYXRlID0gZnVuY3Rpb24oZnJhbWVyYXRlKSB7XG4gICAgaWYgKGZyYW1lcmF0ZSA9PSBudWxsKSB7XG4gICAgICBmcmFtZXJhdGUgPSA2MDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5fRlBTID0gZnJhbWVyYXRlO1xuICB9O1xuXG4gIC8qXG4gIFNldCBzaXplIG9mIGFuIGNhbnZhcyBlbGVtZW50LlxuICBAcGFyYW0ge0ludH0gd2lkdGhcbiAgQHBhcmFtIHtJbnR9IGhlaWdodFxuICBAbWV0aG9kIHNldFNpemVcbiAgKi9cblxuXG4gIEdhbWVDb3JlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IDQwMDtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICBoZWlnaHQgPSAzMDA7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdzaXplQ2hhbmdlZCcsIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuXG4gIEdhbWVDb3JlLnByb3RvdHlwZS5fZnVsbFdpbmRvd1NpemVfcmVzaXplciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnY2k7XG4gICAgZ2NpID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGdjaS5zZXRTaXplKHdpbmRvdy53aWR0aCwgd2luZG93LmhlaWdodCk7XG4gICAgfTtcbiAgfTtcblxuICAvKlxuICBDcmVhdGVzIGEgY2FudmFzIGVsZW1lbnRcbiAgQG1ldGhvZCBjcmVhdGVDYW52YXNcbiAgKi9cblxuXG4gIEdhbWVDb3JlLnByb3RvdHlwZS5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FudmFzO1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHJldHVybiBjYW52YXM7XG4gIH07XG5cbiAgLypcbiAgQ2FsbCB3aW5kb3cncyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gIEBtZXRob2QgX29uRW50ZXJGcmFtZVxuICAqL1xuXG5cbiAgR2FtZUNvcmUucHJvdG90eXBlLl9vbkVudGVyRnJhbWUgPSBmdW5jdGlvbihnY2kpIHtcbiAgICBpZiAoZ2NpID09IG51bGwpIHtcbiAgICAgIGdjaSA9IHRoaXM7XG4gICAgfVxuICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgIGdjaS5fcmVuZGVyKGdjaS5zdGFnZSk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cub25FbnRlckZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGdjaS5fb25FbnRlckZyYW1lKGdjaSk7XG4gICAgfSk7XG4gIH07XG5cbiAgR2FtZUNvcmUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3JlbmRlcl9zdGFydCcpO1xuICAgIHRoaXMuc3RhZ2Uud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIHRoaXMuc3RhZ2UuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5jb250ZXh0LnJlbmRlcihbdGhpcy5zdGFnZV0pO1xuICAgIHRoaXMudHJpZ2dlcigncmVuZGVyX2VuZCcpO1xuICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ3JlbmRlcicpO1xuICB9O1xuXG4gIHJldHVybiBHYW1lQ29yZTtcblxufSkoVHJpZ2dlcmFibGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVDb3JlO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5tYXBcbiovXG5cbn0pKCkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG52YXIgRVJST1JTLCBicm93c2VyUHJlZml4LCBwcmVmaXgsIHVzZXJBZ2VudDtcblxucHJlZml4ID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoYnJvd3NlclByZWZpeCAhPT0gXCJcIikge1xuICAgIG5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gYnJvd3NlclByZWZpeCArIG5hbWU7XG59O1xuXG51c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5icm93c2VyUHJlZml4ID0gKHVzZXJBZ2VudC5tYXRjaCgvb3BlcmEvaSkgJiYgXCJvXCIpIHx8ICh1c2VyQWdlbnQubWF0Y2goL3dlYmtpdC9pKSAmJiBcIndlYmtpdFwiKSB8fCAodXNlckFnZW50Lm1hdGNoKC9tc2llL2kpICYmIFwibXNcIikgfHwgKHVzZXJBZ2VudC5tYXRjaCgvbW96aWxsYS9pKSAmJiBcIm1velwiKSB8fCBcIlwiO1xuXG5GdW5jdGlvbi5wcm90b3R5cGVwcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIGRlc2MpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgcHJvcCwgZGVzYyk7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgSFRNTEVsZW1lbnQucHJvdG90eXBlYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgcmV0dXJuIGF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGNhbGxiYWNrKTtcbiAgfTtcbn1cblxuLypcbndpbmRvdy5vbkVudGVyRnJhbWVcbiovXG5cblxud2luZG93Lm9uRW50ZXJGcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIHdpbmRvdy5fRlBTKTtcbiAgfTtcbn0pKCk7XG5cbi8qXG5Xb3JraW5nIGFyb3VuZCBUeXBlZCBhcnJheXNcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICAvKlxuICBUcnlpbmcgdG8gY3JlYXRlIFVpbnQ4QXJyYXkuIFxuICBJZiBldmVyeXRoaW5nIGlzIG9rIHRoZW4gcmV0dXJuLCBvdGhlcndpc2Ugd2UgbmVlZCB0byBjcmVhdGUgYSBzaW11bGF0aW9uLlxuICBcbiAgQ29kZSBib3Jyb3dlZCBmcm9tIHBkZi5qcyAoaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTA1NzkyNClcbiAgKi9cblxuICB2YXIgVHlwZWRBcnJheSwgYSwgc2V0Xywgc3ViYXJyYXk7XG4gIHRyeSB7XG4gICAgYSA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgIHJldHVybjtcbiAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICBzdWJhcnJheSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKTtcbiAgfTtcbiAgc2V0XyA9IGZ1bmN0aW9uKGFycmF5LCBvZmZzZXQpIHtcbiAgICB2YXIgaSwgbiwgX3Jlc3VsdHM7XG4gICAgaSA9IHZvaWQgMDtcbiAgICBuID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChhcmd1bWVudHNfLmxlbmd0aCA8IDIpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGkgPSAwO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSBhcnJheVtpXSAmIDB4RkY7XG4gICAgICArK2k7XG4gICAgICBfcmVzdWx0cy5wdXNoKCsrb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuICBUeXBlZEFycmF5ID0gZnVuY3Rpb24oYXJnMSkge1xuICAgIHZhciBpLCByZXN1bHQ7XG4gICAgcmVzdWx0ID0gdm9pZCAwO1xuICAgIGkgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkoYXJnMSk7XG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgYXJnMSkge1xuICAgICAgICByZXN1bHRbaV0gPSAwO1xuICAgICAgICArK2k7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGFyZzEuc2xpY2UoMCk7XG4gICAgfVxuICAgIHJlc3VsdC5zdWJhcnJheSA9IHN1YmFycmF5O1xuICAgIHJlc3VsdC5idWZmZXIgPSByZXN1bHQ7XG4gICAgcmVzdWx0LmJ5dGVMZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgIHJlc3VsdC5zZXQgPSBzZXRfO1xuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIiAmJiBhcmcxLmJ1ZmZlcikge1xuICAgICAgcmVzdWx0LmJ1ZmZlciA9IGFyZzEuYnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB3aW5kb3cuVWludDhBcnJheSA9IFR5cGVkQXJyYXk7XG4gIHdpbmRvdy5VaW50MzJBcnJheSA9IFR5cGVkQXJyYXk7XG4gIHJldHVybiB3aW5kb3cuSW50MzJBcnJheSA9IFR5cGVkQXJyYXk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXR0ZXI7XG4gIGlmICh3aW5kb3cub3BlcmEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKFwicmVzcG9uc2VcIiBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUgfHwgXCJtb3pSZXNwb25zZUFycmF5QnVmZmVyXCIgaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlIHx8IFwibW96UmVzcG9uc2VcIiBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUgfHwgXCJyZXNwb25zZUFycmF5QnVmZmVyXCIgaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldHRlciA9IHZvaWQgMDtcbiAgaWYgKHdpbmRvdy5WQkFycmF5KSB7XG4gICAgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFZCQXJyYXkodGhpcy5yZXNwb25zZUJvZHkpLnRvQXJyYXkoKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlQm9keTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLCBcInJlc3BvbnNlXCIsIHtcbiAgICBnZXQ6IGdldHRlclxuICB9KTtcbn0pKCk7XG5cbmlmICghd2luZG93LmJ0b2EpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3aW5kb3cuYnRvYSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBhYywgYjY0LCBiaXRzLCBlbmMsIGgxLCBoMiwgaDMsIGg0LCBpLCBvMSwgbzIsIG8zLCByLCB0bXBfYXJyO1xuICAgICAgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgbzEgPSB2b2lkIDA7XG4gICAgICBvMiA9IHZvaWQgMDtcbiAgICAgIG8zID0gdm9pZCAwO1xuICAgICAgaDEgPSB2b2lkIDA7XG4gICAgICBoMiA9IHZvaWQgMDtcbiAgICAgIGgzID0gdm9pZCAwO1xuICAgICAgaDQgPSB2b2lkIDA7XG4gICAgICBiaXRzID0gdm9pZCAwO1xuICAgICAgaSA9IDA7XG4gICAgICBhYyA9IDA7XG4gICAgICBlbmMgPSBcIlwiO1xuICAgICAgdG1wX2FyciA9IFtdO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgYml0cyA9IG8xIDw8IDE2IHwgbzIgPDwgOCB8IG8zO1xuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICAgICAgaWYgKCEoaSA8IGRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbmMgPSB0bXBfYXJyLmpvaW4oXCJcIik7XG4gICAgICByID0gZGF0YS5sZW5ndGggJSAzO1xuICAgICAgcmV0dXJuIChyID8gZW5jLnNsaWNlKDAsIHIgLSAzKSA6IGVuYykgKyBcIj09PVwiLnNsaWNlKHIgfHwgMyk7XG4gICAgfTtcbiAgfSkoKTtcbn1cblxuLypcbkNoZWNraW5nIGZvciBhYmlsaXR5IHRvIHdvcmtcbiovXG5cblxuRVJST1JTID0gW107XG5cbmlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gIEVSUk9SUy5hcHBlbmQoXCJCcm93c2VyIGRvZXNudCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5cIik7XG59XG5cbmlmICghZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KSB7XG4gIEVSUk9SUy5hcHBlbmQoXCJCcm93c2VyIGRvZXNudCBzdXBwb3J0IDxjYW52YXM+IGFuZCB0aGUgQ2FudmFzMkQgQVBJLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qXG4gICovXG5cbiAgRVJST1JTOiBFUlJPUlMsXG4gIC8qXG4gIEJyb3dzZXIncyB1c2VyLWFnZW50IHN0cmluZ1xuICBAYXR0cmlidXRlIHVzZXJBZ2VudFxuICBAdHlwZSB7U3RyaW5nfVxuICBAc3RhdGljXG4gIEByZWFkb25seVxuICAqL1xuXG4gIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAvKlxuICBEZXZpY2Ugc3VwcG9ydHMgdG91Y2ggZXZlbnRzP1xuICBAYXR0cmlidXRlIHRvdWNoXG4gIEB0eXBlIHtCb29sZWFufVxuICBAc3RhdGljXG4gIEByZWFkb25seVxuICAqL1xuXG4gIHRvdWNoOiBcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyxcbiAgLypcbiAgRGV2aWNlIHN1cHBvcnRzIFJldGluYSBEaXNwbGF5P1xuICBAYXR0cmlidXRlIHJldGluYVxuICBAdHlwZSB7Qm9vbGVhbn1cbiAgQHN0YXRpY1xuICBAcmVhZG9ubHlcbiAgKi9cblxuICByZXRpbmE6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMSB8fCB3aW5kb3cubWF0Y2hNZWRpYShcIihtaW4tcmVzb2x1dGlvbjogMS4xZHBweClcIikubWF0Y2hlcyxcbiAgaW1hZ2VTbW9vdGhpbmdFbmFibGVkOiBwcmVmaXgoXCJpbWFnZVNtb290aGluZ0VuYWJsZWRcIilcbn07XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD1zdXBwb3J0Lm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbnZhciBFdmVudHMsIFRyaWdnZXJhYmxlLCBzdXBwb3J0LFxuICBfX3NsaWNlID0gW10uc2xpY2U7XG5cbnN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcblxuRXZlbnRzID0ge1xuICBJTklUOiAnaW5pdCdcbn07XG5cblRyaWdnZXJhYmxlID0gKGZ1bmN0aW9uKCkge1xuICAvKlxuICBFdmVudCB0cmlnZ2VyaW5nIGFuZCBoYW5kbGluZy5cbiAgXG4gIEBjbGFzcyBUcmlnZ2VyYWJsZVxuICBAY29uc3RydWN0b3JcbiAgKi9cblxuICBmdW5jdGlvbiBUcmlnZ2VyYWJsZShvcHRpb25zKSB7XG4gICAgdmFyIGssIHY7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9O1xuICAgIGZvciAoayBpbiBFdmVudHMpIHtcbiAgICAgIHYgPSBFdmVudHNba107XG4gICAgICB0aGlzLmV2ZW50c1trXSA9IHY7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZXJzID0gb3B0aW9ucy5faGFuZGxlcnMgfHwge307XG4gICAgdGhpcy5fYmVoYXZpb3VycyA9IG9wdGlvbnMuX2JlaGF2aW91cnMgfHwgW107XG4gIH1cblxuICAvKlxuICBCZWhhdmUgbGlrZSBhIHtCZWhhdmlvdXJ9XG4gIEBtZXRob2QgYmVoYXZlXG4gIEBwYXJhbSB7U3RyaW5nIHwgQmVoYXZpb3VyfSBiZWhhdmlvdXJcbiAgQHJldHVybiB7VHJpZ2dlcmFibGV9IHRoaXNcbiAgKi9cblxuXG4gIFRyaWdnZXJhYmxlLnByb3RvdHlwZS5iZWhhdmUgPSBmdW5jdGlvbihCZWhhdmlvdXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgYmVoYXZpb3VyLCBiZWhhdmlvdXJzLCBpLCBsLCBsYXN0O1xuICAgIGkgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGVvZiBCZWhhdmlvdXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxhc3QgPSB2b2lkIDA7XG4gICAgICBiZWhhdmlvdXJzID0gQmVoYXZpb3VyLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSAwO1xuICAgICAgbCA9IGJlaGF2aW91cnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBsKSB7XG4gICAgICAgIGxhc3QgPSB0aGlzLmJlaGF2ZShCZWhhdmlvdXJzLmdldChiZWhhdmlvdXJzW2ldLnJlcGxhY2UoXCIgXCIsIFwiXCIpKSwgb3B0aW9ucyk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbiAgICB0aGlzLl9iZWhhdmlvdXJzLnB1c2goQmVoYXZpb3VyLmlkKTtcbiAgICBiZWhhdmlvdXIgPSBuZXcgQmVoYXZpb3VyKG9wdGlvbnMpO1xuICAgIGZvciAoaSBpbiBiZWhhdmlvdXIpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ldmVudHNbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5iaW5kKHRoaXMuZXZlbnRzW2ldLCBiZWhhdmlvdXJbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGkgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgIHRoaXNbaV0gPSBiZWhhdmlvdXJbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLypcbiAgVGhpcyBvYmplY3QgYmVoYXZlcyBhcyB7dGFyZ2V0fSBiZWhhdmlvdXI/XG4gIEBtZXRob2QgaGFzQmVoYXZpb3VyXG4gIEBwYXJhbSB7U3RyaW5nfSBiZWhhdmlvdXJOYW1lXG4gIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuICBUcmlnZ2VyYWJsZS5wcm90b3R5cGUuaGFzQmVoYXZpb3VyID0gZnVuY3Rpb24oYmVoYXZpb3VyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JlaGF2aW91cnMuaW5kZXhPZihiZWhhdmlvdXIpID49IDA7XG4gIH07XG5cbiAgLypcbiAgQmluZCBldmVudCBoYW5kbGVyXG4gIEBtZXRob2QgYmluZFxuICBAcGFyYW0ge1N0cmluZ30gdHlwZSBldmVudCB0eXBlXG4gIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgQHJldHVybiB7VHJpZ2dlcmFibGV9IHRoaXNcbiAgKi9cblxuXG4gIFRyaWdnZXJhYmxlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBkYXRhO1xuICAgIGRhdGEgPSBoYW5kbGVyO1xuICAgIGlmIChUcmlnZ2VyYWJsZS5fY3VzdG9tLmJpbmRbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICB9O1xuICAgICAgVHJpZ2dlcmFibGUuX2N1c3RvbS5iaW5kW3R5cGVdLmNhbGwodGhpcywgZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9oYW5kbGVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9oYW5kbGVyc1t0eXBlXSA9IFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5faGFuZGxlcnNbdHlwZV0uaW5kZXhPZihkYXRhKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXJzW3R5cGVdLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qXG4gIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICBAbWV0aG9kIHVuYmluZFxuICBAcGFyYW0ge1N0cmluZ30gdHlwZSBldmVudCB0eXBlXG4gIEByZXR1cm4ge1RyaWdnZXJhYmxlfSB0aGlzXG4gICovXG5cblxuICBUcmlnZ2VyYWJsZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKFRyaWdnZXJhYmxlLl9jdXN0b20udW5iaW5kW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGkgPSAwO1xuICAgICAgbGVuZ3RoID0gdGhpcy5faGFuZGxlcnNbdHlwZV0ubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgVHJpZ2dlcmFibGUuX2N1c3RvbS51bmJpbmRbdHlwZV0uY2FsbCh0aGlzLCB0aGlzLl9oYW5kbGVyc1t0eXBlXVtpXSk7XG4gICAgICAgICsraTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faGFuZGxlcnNbdHlwZV0gPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qXG4gIFRyaWdnZXJzIGV2ZW50IHR5cGVcbiAgQG1ldGhvZCB0cmlnZ2VyXG4gIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGV2ZW50IHR5cGVcbiAgQHBhcmFtIHtWYXJpYWJsZX0gYXJndW1lbnRzIGFyZ3VtZW50cyBmb3IgY2FsbGJhY2tcbiAgQG9wdGlvbmFsXG4gICovXG5cblxuICBUcmlnZ2VyYWJsZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzLCBoYW5kbGVycywgaSwgbGVuZ3RoLCB0eXBlLCBfcmVmLCBfcmVzdWx0cztcbiAgICB0eXBlID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgIGkgPSAwO1xuICAgIGxlbmd0aCA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAoX3JlZiA9IGhhbmRsZXJzW2ldKS5hcHBseS5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgX3Jlc3VsdHMucHVzaCgrK2kpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgVHJpZ2dlcmFibGUuX2N1c3RvbSA9IHtcbiAgICBiaW5kOiB7fSxcbiAgICB1bmJpbmQ6IHt9XG4gIH07XG5cbiAgLypcbiAgUmVnaXN0ZXIgZGVmYXVsdCBtZXRob2QgaGFuZGxlci5cbiAgQG1ldGhvZCByZWdpc3RlclxuICBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICBAcGFyYW0ge0Z1bmN0aW9ufSBiaW5kQ2FsbGJhY2tcbiAgQHBhcmFtIHtGdW5jdGlvbn0gdW5iaW5kQ2FsbGJhY2tcbiAgXG4gIEBzdGF0aWNcbiAgKi9cblxuXG4gIFRyaWdnZXJhYmxlLnJlZ2lzdGVyID0gZnVuY3Rpb24odHlwZSwgYmluZENhbGxiYWNrLCB1bmJpbmRDYWxsYmFjaykge1xuICAgIFRyaWdnZXJhYmxlLl9jdXN0b20uYmluZFt0eXBlXSA9IGJpbmRDYWxsYmFjaztcbiAgICBUcmlnZ2VyYWJsZS5fY3VzdG9tLnVuYmluZFt0eXBlXSA9IHVuYmluZENhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFRyaWdnZXJhYmxlLnJlZ2lzdGVyKEV2ZW50cy5JTklULCBmdW5jdGlvbihldnQpIHtcbiAgICByZXR1cm4gZXZ0LmhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIFRyaWdnZXJhYmxlO1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWdnZXJhYmxlO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9dHJpZ2dlcmFibGUubWFwXG4qL1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xudmFyIHN1cHBvcnQ7XG5cbnN1cHBvcnQgPSByZXF1aXJlKFwiLi9jb3JlL3N1cHBvcnRcIik7XG5cbndpbmRvdy5HYW1lQ29yZSA9IHdpbmRvdy5HYW1lQ29yZSB8fCByZXF1aXJlKFwiLi9jb3JlL2NvcmVcIik7XG5cbndpbmRvdy5HYW1lQ29yZS5leHBvcnRzID0ge1xuICBVSTogcmVxdWlyZShcIi4vdWkvZXhwb3J0c1wiKSxcbiAgTWF0aDogcmVxdWlyZShcIi4vbWF0aC9leHBvcnRzXCIpLFxuICBVdGlsczogcmVxdWlyZShcIi4vdXRpbHMvZXhwb3J0c1wiKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHYW1lQ29yZTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWdhbWVjb3JlLm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBNYXRyaXgyRDogcmVxdWlyZShcIi4vbWF0cml4MmRcIiksXG4gIFZlY3RvcjJEOiByZXF1aXJlKFwiLi92ZWN0b3IyZFwiKSxcbiAgVVVJRDogcmVxdWlyZShcIi4vdXVpZFwiKSxcbiAgTWF0aDogcmVxdWlyZShcIi4vbWF0aFwiKVxufTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWV4cG9ydHMubWFwXG4qL1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xuLypcbk1hdGhlbWF0aWNhbCBmdW5jdGlvbnNcblxuQG5vdGUgR2FtZUNvcmUuZXhwb3J0cy5NYXRoLk1hdGhcblxuQHNlZSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0LWhpc3RvcnkvNDE4ZWYyMGIyOWU4ZjNlYmI1MTIxMjY2ZWM3MjA2YWU2OTQzZDI4ZC9jbG9zdXJlX2dvb2dfbWF0aF9tYXRoLmpzLnNvdXJjZS5odG1sXG4qL1xuXG52YXIgTWF0aGVtYXRpY3M7XG5cbk1hdGhlbWF0aWNzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNYXRoZW1hdGljcygpIHt9XG5cbiAgLypcbiAgQ2xhbXBpbmcgYSBudW1iZXIgaW50byBhIGxpbWl0c1xuICBcbiAgQG1ldGhvZCBjbGFtcFxuICBAcGFyYW0ge051bWJlcn0gbnVtXG4gIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAgQHBhcmFtIHtOdW1iZXJ9IG1heFxuICBAcmV0dXJuIHtOdW1iZXJ9XG4gICovXG5cblxuICBNYXRoZW1hdGljcy5jbGFtcCA9IGZ1bmN0aW9uKG51bSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xuICB9O1xuXG4gIC8qXG4gIEFsaWFzIHRvIEBjbGFtcChudW0sIDAsIDEpXG4gIFxuICBAbWV0aG9kIGNsYW1wMDFcbiAgQHBhcmFtIHtOdW1iZXJ9IG51bVxuICBAcmV0dXJuIHtOdW1iZXJ9XG4gICovXG5cblxuICBNYXRoZW1hdGljcy5jbGFtcDAxID0gZnVuY3Rpb24obnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhbXAobnVtLCAwLCAxKTtcbiAgfTtcblxuICAvKlxuICBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICRtaW4gYW5kIGxlc3MgdGhhbiAkbWF4LlxuICBcbiAgQHBhcmFtIHtOdW1iZXJ9IGEgIFRoZSBsb3dlciBib3VuZCBmb3IgdGhlIHJhbmRvbSBpbnRlZ2VyIGluY2x1c2l2ZSAoZGVmYXVsdD0wKS5cbiAgQHBhcmFtIHtOdW1iZXJ9IGEgIFRoZSB1cHBlciBib3VuZCBmb3IgdGhlIHJhbmRvbSBpbnRlZ2VyIGV4bHVzaXZlIChkZWZhdWx0PTEwMDApLlxuICBAcmV0dXJuIHtOdW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgTiBzdWNoIHRoYXQgJG1pbiA8PSBOIDwgJG1heC5cbiAgKi9cblxuXG4gIE1hdGhlbWF0aWNzLnJhbmRvbUludCA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKTtcbiAgfTtcblxuICAvKlxuICBUaGUgJSBvcGVyYXRvciBpbiBKYXZhU2NyaXB0IHJldHVybnMgdGhlIHJlbWFpbmRlciBvZiBhIC8gYiwgYnV0IGRpZmZlcnMgZnJvbVxuICBzb21lIG90aGVyIGxhbmd1YWdlcyBpbiB0aGF0IHRoZSByZXN1bHQgd2lsbCBoYXZlIHRoZSBzYW1lIHNpZ24gYXMgdGhlXG4gIGRpdmlkZW5kLiBGb3IgZXhhbXBsZSwgLTEgJSA4ID09IC0xLCB3aGVyZWFzIGluIHNvbWUgb3RoZXIgbGFuZ3VhZ2VzXG4gIChzdWNoIGFzIFB5dGhvbikgdGhlIHJlc3VsdCB3b3VsZCBiZSA3LiBUaGlzIGZ1bmN0aW9uIGVtdWxhdGVzIHRoZSBtb3JlXG4gIGNvcnJlY3QgbW9kdWxvIGJlaGF2aW9yLCB3aGljaCBpcyB1c2VmdWwgZm9yIGNlcnRhaW4gYXBwbGljYXRpb25zIHN1Y2ggYXNcbiAgY2FsY3VsYXRpbmcgYW4gb2Zmc2V0IGluZGV4IGluIGEgY2lyY3VsYXIgbGlzdC5cbiAgIFxuICBAcGFyYW0ge251bWJlcn0gYSBUaGUgZGl2aWRlbmQuXG4gIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBkaXZpc29yLlxuICBAcmV0dXJuIHtudW1iZXJ9IGEgJSBiIHdoZXJlIHRoZSByZXN1bHQgaXMgYmV0d2VlbiAwIGFuZCBiIChlaXRoZXIgMCA8PSB4IDwgYlxuICAgIG9yIGIgPCB4IDw9IDAsIGRlcGVuZGluZyBvbiB0aGUgc2lnbiBvZiBiKS5cbiAgKi9cblxuXG4gIE1hdGhlbWF0aWNzLm1vZHVsbyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcjtcbiAgICByID0gYSAlIGI7XG4gICAgaWYgKHIgKiBiIDwgMCkge1xuICAgICAgcmV0dXJuIHIgKyBiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB2YWx1ZXMgYSBhbmQgYi4gUmV0dXJucyB0aGUgdmFsdWVcbiAgYmV0d2VlbiBhIGFuZCBiIHByb3BvcnRpb25hbCB0byB4ICh3aGVuIHggaXMgYmV0d2VlbiAwIGFuZCAxLiBXaGVuIHggaXNcbiAgb3V0c2lkZSB0aGlzIHJhbmdlLCB0aGUgcmV0dXJuIHZhbHVlIGlzIGEgbGluZWFyIGV4dHJhcG9sYXRpb24pLlxuICBcbiAgQHBhcmFtIHtudW1iZXJ9IGEgQSBudW1iZXIuXG4gIEBwYXJhbSB7bnVtYmVyfSBiIEEgbnVtYmVyLlxuICBAcGFyYW0ge251bWJlcn0geCBUaGUgcHJvcG9ydGlvbiBiZXR3ZWVuIGEgYW5kIGIuXG4gIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIuXG4gICovXG5cblxuICBNYXRoZW1hdGljcy5sZXJwID0gZnVuY3Rpb24oYSwgYiwgeCkge1xuICAgIHJldHVybiBhICsgeCAqIChiIC0gYSk7XG4gIH07XG5cbiAgLypcbiAgVGVzdHMgd2hldGhlciB0aGUgdHdvIHZhbHVlcyBhcmUgZXF1YWwgdG8gZWFjaCBvdGhlciwgd2l0aGluIGEgY2VydGFpblxuICB0b2xlcmFuY2UgdG8gYWRqdXN0IGZvciBmbG9hdGluZyBwb3VudCBlcnJvcnMuXG4gIFxuICBAcGFyYW0ge051bWJlcn0gYSBBIG51bWJlci5cbiAgQHBhcmFtIHtOdW1iZXJ9IGIgQSBudW1iZXIuXG4gIEBwYXJhbSB7TnVtYmVyPX0gb3B0X3RvbGVyYW5jZSBPcHRpb25hbCB0b2xlcmFuY2UgcmFuZ2UuXG4gICAgICBEZWZhdWx0cyB0byAwLjAwMDAwMS4gSWYgc3BlY2lmaWVkLCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXG4gIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgJGEgYW5kICRiIGFyZSBuZWFybHkgZXF1YWwuXG4gICovXG5cblxuICBNYXRoZW1hdGljcy5uZWFybHlFcXVhbHMgPSBmdW5jdGlvbihhLCBiLCBvcHRfdG9sZXJhbmNlKSB7XG4gICAgaWYgKG9wdF90b2xlcmFuY2UgPT0gbnVsbCkge1xuICAgICAgb3B0X3RvbGVyYW5jZSA9IDAuMDAwMDAxO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IG9wdF90b2xlcmFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIE1hdGhlbWF0aWNzO1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGhlbWF0aWNzO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC5tYXBcbiovXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG4vKlxuMkQgTWF0cml4IG1hbmlwdWxhdGlvbnNcblxuQG5vdGUgR2FtZUNvcmUuZXhwb3J0cy5NYXRoLk1hdHJpeDJEXG4qL1xuXG52YXIgTWF0cml4MkQ7XG5cbk1hdHJpeDJEID0gKGZ1bmN0aW9uKCkge1xuICAvKiAgICAgICAgICAgXG4gIE11bHRpcGxpZXIgZm9yIGNvbnZlcnRpbmcgZGVncmVlcyB0byByYWRpYW5zLiBVc2VkIGludGVybmFsbHkgYnkgTWF0cml4MkQuXG4gIFxuICBAYXR0cmlidXRlIERFR19UT19SQURcbiAgQHN0YXRpY1xuICBAcmVhZG9ubHlcbiAgQHJldHVybiB7TnVtYmVyfVxuICAqL1xuXG4gIE1hdHJpeDJELkRFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG4gIC8qXG4gIEJhc2VkIG9uIFtFYXNlbEpTXShodHRwczovL2dpdGh1Yi5jb20vQ3JlYXRlSlMvRWFzZWxKUy8pIE1hdHJpeDJEIGltcGxlbWVudGF0aW9uLlxuICBcbiAgQGNsYXNzIE1hdHJpeDJEXG4gIEBjb25zdHJ1Y3RvclxuICBcbiAgQHBhcmFtIHtOdW1iZXJ9IG0xMVxuICBAcGFyYW0ge051bWJlcn0gbTEyXG4gIEBwYXJhbSB7TnVtYmVyfSBtMjFcbiAgQHBhcmFtIHtOdW1iZXJ9IG0yMlxuICBAcGFyYW0ge051bWJlcn0gZHhcbiAgQHBhcmFtIHtOdW1iZXJ9IGR5XG4gICovXG5cblxuICBmdW5jdGlvbiBNYXRyaXgyRChtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSkge1xuICAgIGlmIChtMTEgIT09IG51bGwpIHtcbiAgICAgIHRoaXMubTExID0gbTExO1xuICAgIH1cbiAgICB0aGlzLm0xMiA9IG0xMiB8fCAwO1xuICAgIHRoaXMubTIxID0gbTIxIHx8IDA7XG4gICAgaWYgKG0yMiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5tMjIgPSBtMjI7XG4gICAgfVxuICAgIHRoaXMuZHggPSBkeCB8fCAwO1xuICAgIHRoaXMuZHkgPSBkeSB8fCAwO1xuICB9XG5cbiAgLypcbiAgR2VuZXJhdGVzIG1hdHJpeCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCB0cmFuc2Zvcm0gcHJvcGVydGllcywgYW5kIGFwcGVuZHMgdGhlbSB3aXRoIHRoaXMgbWF0cml4LlxuICBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgdGhpcyB0byBnZW5lcmF0ZSBtMTEgbWF0cml4IGZyb20gbTExIGRpc3BsYXkgb2JqZWN0OiB2YXIgbXR4ID0gbmV3IE1hdHJpeDJEKCk7XG4gIG10eC5hcHBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbik7XG4gIEBtZXRob2QgYXBwZW5kVHJhbnNmb3JtXG4gIEBwYXJhbSB7TnVtYmVyfSB4XG4gIEBwYXJhbSB7TnVtYmVyfSB5XG4gIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgQHBhcmFtIHtOdW1iZXJ9IHNrZXdYXG4gIEBwYXJhbSB7TnVtYmVyfSBza2V3WVxuICBAcGFyYW0ge051bWJlcn0gcGl2b3RYIE9wdGlvbmFsLlxuICBAcGFyYW0ge051bWJlcn0gcGl2b3RZIE9wdGlvbmFsLlxuICBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAqL1xuXG5cbiAgTWF0cml4MkQucHJvdG90eXBlLmFwcGVuZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBwaXZvdFgsIHBpdm90WSkge1xuICAgIHZhciBjb3MsIHIsIHNpbjtcbiAgICBjb3MgPSB2b2lkIDA7XG4gICAgc2luID0gdm9pZCAwO1xuICAgIHIgPSB2b2lkIDA7XG4gICAgaWYgKHJvdGF0aW9uICUgMzYwKSB7XG4gICAgICByID0gcm90YXRpb24gKiBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuICAgICAgY29zID0gTWF0aC5jb3Mocik7XG4gICAgICBzaW4gPSBNYXRoLnNpbihyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29zID0gMTtcbiAgICAgIHNpbiA9IDA7XG4gICAgfVxuICAgIGlmIChza2V3WCB8fCBza2V3WSkge1xuICAgICAgc2tld1ggKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcbiAgICAgIHNrZXdZICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG4gICAgICB0aGlzLmFwcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCB4LCB5KTtcbiAgICAgIHRoaXMuYXBwZW5kKGNvcyAqIHNjYWxlWCwgc2luICogc2NhbGVYLCAtc2luICogc2NhbGVZLCBjb3MgKiBzY2FsZVksIDAsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGVuZChjb3MgKiBzY2FsZVgsIHNpbiAqIHNjYWxlWCwgLXNpbiAqIHNjYWxlWSwgY29zICogc2NhbGVZLCB4LCB5KTtcbiAgICB9XG4gICAgaWYgKHBpdm90WCB8fCBwaXZvdFkpIHtcbiAgICAgIHRoaXMuZHggLT0gcGl2b3RYICogdGhpcy5tMTEgKyBwaXZvdFkgKiB0aGlzLm0yMTtcbiAgICAgIHRoaXMuZHkgLT0gcGl2b3RYICogdGhpcy5tMTIgKyBwaXZvdFkgKiB0aGlzLm0yMjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLypcbiAgQXBwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCBwcm9wZXJ0aWVzIHdpdGggdGhpcyBtYXRyaXguIEFsbCBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC5cbiAgQG1ldGhvZCBhcHBlbmRcbiAgQHBhcmFtIHtOdW1iZXJ9IG0xMVxuICBAcGFyYW0ge051bWJlcn0gbTEyXG4gIEBwYXJhbSB7TnVtYmVyfSBtMjFcbiAgQHBhcmFtIHtOdW1iZXJ9IG0yMlxuICBAcGFyYW0ge051bWJlcn0gZHhcbiAgQHBhcmFtIHtOdW1iZXJ9IGR5XG4gIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICovXG5cblxuICBNYXRyaXgyRC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpIHtcbiAgICB2YXIgYTEsIGIxLCBjMSwgZDE7XG4gICAgYTEgPSB0aGlzLm0xMTtcbiAgICBiMSA9IHRoaXMubTEyO1xuICAgIGMxID0gdGhpcy5tMjE7XG4gICAgZDEgPSB0aGlzLm0yMjtcbiAgICB0aGlzLm0xMSA9IG0xMSAqIGExICsgbTEyICogYzE7XG4gICAgdGhpcy5tMTIgPSBtMTEgKiBiMSArIG0xMiAqIGQxO1xuICAgIHRoaXMubTIxID0gbTIxICogYTEgKyBtMjIgKiBjMTtcbiAgICB0aGlzLm0yMiA9IG0yMSAqIGIxICsgbTIyICogZDE7XG4gICAgdGhpcy5keCA9IGR4ICogYTEgKyBkeSAqIGMxICsgdGhpcy5keDtcbiAgICB0aGlzLmR5ID0gZHggKiBiMSArIGR5ICogZDEgKyB0aGlzLmR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qXG4gIEludmVydHMgdGhlIG1hdHJpeCwgY2F1c2luZyBpdCB0byBwZXJmb3JtIHRoZSBvcHBvc2l0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgQG1ldGhvZCBpbnZlcnRcbiAgQHJldHVybiB7TWF0cml4MkR9IHRoaXNcbiAgKi9cblxuXG4gIE1hdHJpeDJELnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYTEsIGIxLCBjMSwgZDEsIG4sIHR4MTtcbiAgICBhMSA9IHRoaXMubTExO1xuICAgIGIxID0gdGhpcy5tMTI7XG4gICAgYzEgPSB0aGlzLm0yMTtcbiAgICBkMSA9IHRoaXMubTIyO1xuICAgIHR4MSA9IHRoaXMuZHg7XG4gICAgbiA9IGExICogZDEgLSBiMSAqIGMxO1xuICAgIHRoaXMubTExID0gZDEgLyBuO1xuICAgIHRoaXMubTEyID0gLWIxIC8gbjtcbiAgICB0aGlzLm0yMSA9IC1jMSAvIG47XG4gICAgdGhpcy5tMjIgPSBhMSAvIG47XG4gICAgdGhpcy5keCA9IChjMSAqIHRoaXMuZHkgLSBkMSAqIHR4MSkgLyBuO1xuICAgIHRoaXMuZHkgPSAtKGExICogdGhpcy5keSAtIGIxICogdHgxKSAvIG47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLypcbiAgQ2xvbmUgTWF0cml4MkQgaW5zdGFuY2VcbiAgQHJldHVybiB7TWF0cml4MkR9XG4gICovXG5cblxuICBNYXRyaXgyRC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMubTExLCB0aGlzLm0xMiwgdGhpcy5tMjEsIHRoaXMubTIyLCB0aGlzLmR4LCB0aGlzLmR5KTtcbiAgfTtcblxuICAvKlxuICBSZXNldCBtYXRyaXggdG8gaXQncyBpZGVudGl0eVxuICBAcmV0dXJuIHtNYXRyaXgyRH0gdGhpc1xuICAqL1xuXG5cbiAgTWF0cml4MkQucHJvdG90eXBlLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tMTEgPSB0aGlzLm0yMiA9IDE7XG4gICAgdGhpcy5tMTIgPSB0aGlzLm0yMSA9IHRoaXMuZHggPSB0aGlzLmR5ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBNYXRyaXgyRC5pZGVudGl0eSA9IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICByZXR1cm4gTWF0cml4MkQ7XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4MkQ7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD1tYXRyaXgyZC5tYXBcbiovXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG4vKlxuVW5pcXVlIElEIGdlbmVyYXRvclxuXG5Abm90ZSBHYW1lQ29yZS5leHBvcnRzLk1hdGguVVVJRFxuKi9cblxudmFyIFVVSUQ7XG5cblVVSUQgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFVVSUQoKSB7fVxuXG4gIC8qXG4gIEBtZXRob2QgZ2VuZXJhdGVVbmlxdWVJZFxuICBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5cblxuICBVVUlELmdlbmVyYXRlVW5pcXVlSWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJnYy1cIiArIHRoaXMudXVpZCgpO1xuICB9O1xuXG4gIC8qXG4gIEBtZXRob2QgdXVpZFxuICBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5cblxuICBVVUlELnV1aWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgciwgdjtcbiAgICAgIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuICAgICAgdiA9IGMgPT09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBVVUlEO1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVVSUQ7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD11dWlkLm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbi8qXG4yRCBWZWN0b3IgbWFuaXB1bGF0aW9uc1xuXG5Abm90ZSBHYW1lQ29yZS5leHBvcnRzLk1hdGguVmVjdG9yMkRcbiovXG5cbnZhciBWZWN0b3IyZDtcblxuVmVjdG9yMmQgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFZlY3RvcjJkKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4ICE9IG51bGwgPyB4IDogMDtcbiAgICB0aGlzLnkgPSB5ICE9IG51bGwgPyB5IDogMDtcbiAgICAvKlxuICAgIEdldCB0aGUgbWFnbml0dWRlIG9mIHRoaXMgdmVjdG9yXG4gICAgQGF0dHJpYnV0ZSBsZW5ndGhcbiAgICBAcmVhZG9ubHlcbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGVuZ3RoXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHRoaXMueCAqIHRoaXMueCkgKyAodGhpcy55ICogdGhpcy55KSk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLypcbiAgICBHZXQgdGhpcyB2ZWN0b3Igd2l0aCBhIG1hZ25pdHVkZSBvZiAxLlxuICAgIEBhdHRyaWJ1dGUgbm9ybWFsaXplZFxuICAgIEByZWFkb25seVxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub3JtYWxpemVkXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYWduaXR1ZGU7XG4gICAgICAgIG1hZ25pdHVkZSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjJkKHRoaXMueCAvIG1hZ25pdHVkZSwgdGhpcy55IC8gbWFnbml0dWRlKTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qXG4gIEBtZXRob2Qgc2V0XG4gIEBwYXJhbSB7TnVtYmVyfSB4XG4gIEBwYXJhbSB7TnVtYmVyfSB5XG4gIEByZXR1cm4ge1ZlY3RvcjJkfVxuICAqL1xuXG5cbiAgVmVjdG9yMmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH07XG5cbiAgLypcbiAgQG1ldGhvZCBzdW1cbiAgQHBhcmFtIHtWZWN0b3IyZH0gdmVjdG9yMmRcbiAgQHJldHVybiB7VmVjdG9yMmR9XG4gICovXG5cblxuICBWZWN0b3IyZC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbih2ZWN0b3IyZCkge1xuICAgIHRoaXMueCAtPSB2ZWN0b3IyZC54O1xuICAgIHJldHVybiB0aGlzLnkgLT0gdmVjdG9yMmQueTtcbiAgfTtcblxuICAvKlxuICBAbWV0aG9kIHN1bVxuICBAcGFyYW0ge1ZlY3RvcjJkfSB2ZWN0b3IyZFxuICBAcmV0dXJuIHtWZWN0b3IyZH1cbiAgKi9cblxuXG4gIFZlY3RvcjJkLnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbih2ZWN0b3IyZCkge1xuICAgIHRoaXMueCArPSB2ZWN0b3IyZC54O1xuICAgIHJldHVybiB0aGlzLnkgKz0gdmVjdG9yMmQueTtcbiAgfTtcblxuICAvKlxuICBAbWV0aG9kIHNjYWxlXG4gIEBwYXJhbSB7TnVtYmVyfSB4IChvciB4IHkpXG4gIEBwYXJhbSB7TnVtYmVyfSB5XG4gIEByZXR1cm4ge1ZlY3RvcjJkfVxuICAqL1xuXG5cbiAgVmVjdG9yMmQucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMueCAqPSB4O1xuICAgIHJldHVybiB0aGlzLnkgKj0geSB8fCB4O1xuICB9O1xuXG4gIC8qXG4gIEBtZXRob2QgY2xvbmVcbiAgQHJldHVybiB7VmVjdG9yMmR9XG4gICovXG5cblxuICBWZWN0b3IyZC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjJkKHRoaXMueCwgdGhpcy55KTtcbiAgfTtcblxuICAvKlxuICBSZXR1cm4gdW5pdCB2ZWN0b3JcbiAgQHJldHVybiB7VmVjdG9yMmR9XG4gICovXG5cblxuICBWZWN0b3IyZC5wcm90b3R5cGUudW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMmQoTWF0aC5jb3ModGhpcy54KSwgTWF0aC5zaW4odGhpcy55KSk7XG4gIH07XG5cbiAgLypcbiAgTm9ybWFsaXplIHRoaXMgdmVjdG9yXG4gIEByZXR1cm4ge1ZlY3RvcjJkfVxuICAqL1xuXG5cbiAgVmVjdG9yMmQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub3JtYWw7XG4gICAgbm9ybWFsID0gdGhpcy5ub3JtYWxpemVkO1xuICAgIHRoaXMueCA9IG5vcm1hbC54O1xuICAgIHJldHVybiB0aGlzLnkgPSBub3JtYWwueTtcbiAgfTtcblxuICAvKlxuICBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIHRoZSBhcmd1bWVudCB2ZWN0b3JcbiAgQHBhcmFtIHtWZWN0b3IyZH0gdmVjdG9yXG4gIEByZXR1cm4ge051bWJlcn1cbiAgKi9cblxuXG4gIFZlY3RvcjJkLmRpc3RhbmNlID0gZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgdmFyIHhkaWZmLCB5ZGlmZjtcbiAgICB4ZGlmZiA9IHYxLnggLSB2Mi54O1xuICAgIHlkaWZmID0gdjEueSAtIHYyLnk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG4gIH07XG5cbiAgLypcbiAgQG1ldGhvZCB0b1N0cmluZ1xuICBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5cblxuICBWZWN0b3IyZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCIjPFZlY3RvcjJkIEB4PVwiICsgdGhpcy54ICsgXCIsIEB5PVwiICsgdGhpcy55ICsgXCI+XCI7XG4gIH07XG5cbiAgVmVjdG9yMmQuTEVGVCA9IG5ldyBWZWN0b3IyZCgtMSwgMCk7XG5cbiAgVmVjdG9yMmQuUklHSFQgPSBuZXcgVmVjdG9yMmQoMSwgMCk7XG5cbiAgVmVjdG9yMmQuVE9QID0gbmV3IFZlY3RvcjJkKDAsIC0xKTtcblxuICBWZWN0b3IyZC5CT1RUT00gPSBuZXcgVmVjdG9yMmQoMCwgMSk7XG5cbiAgcmV0dXJuIFZlY3RvcjJkO1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjJkO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yMmQubWFwXG4qL1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xudmFyIENvbnRhaW5lciwgV2lkZ2V0LFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbldpZGdldCA9IHJlcXVpcmUoXCIuL3dpZGdldFwiKTtcblxuLypcbkJhc2Ugd2lkZ2V0cyBjb250YWluZXJcbkBub3RlIEdhbWVDb3JlLmV4cG9ydHMudWkuQ29udGFpbmVyXG4qL1xuXG5cbkNvbnRhaW5lciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgX19leHRlbmRzKENvbnRhaW5lciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDb250YWluZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgQ29udGFpbmVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgfVxuXG4gIENvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09ICF0aGlzKSB7XG4gICAgICByZXR1cm4gY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bY2hpbGQuaWRdID0gY2hpbGQ7XG4gICAgfVxuICB9O1xuXG4gIENvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIGNoaWxkLCBjaWQsIF9yZWYsIF9yZXN1bHRzO1xuICAgIENvbnRhaW5lci5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcywgY3R4KTtcbiAgICBfcmVmID0gdGhpcy5jaGlsZHJlbjtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY2lkIGluIF9yZWYpIHtcbiAgICAgIGNoaWxkID0gX3JlZltjaWRdO1xuICAgICAgX3Jlc3VsdHMucHVzaChjaGlsZC5yZW5kZXIoY3R4KSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICByZXR1cm4gQ29udGFpbmVyO1xuXG59KShXaWRnZXQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lcjtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5lci5tYXBcbiovXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2lkZ2V0OiByZXF1aXJlKFwiLi93aWRnZXRcIiksXG4gIFN0YWdlOiByZXF1aXJlKFwiLi9zdGFnZVwiKSxcbiAgQ29udGFpbmVyOiByZXF1aXJlKFwiLi9jb250YWluZXJcIiksXG4gIFRleHQ6IHJlcXVpcmUoXCIuL3RleHRcIiksXG4gIFNwcml0ZTogcmVxdWlyZShcIi4vc3ByaXRlXCIpLFxuICBnZW9tZXRyeTogcmVxdWlyZShcIi4vZ2VvbWV0cnkvZXhwb3J0c1wiKVxufTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWV4cG9ydHMubWFwXG4qL1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xudmFyIENpcmNsZSwgV2lkZ2V0LFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbldpZGdldCA9IHJlcXVpcmUoXCIuLi93aWRnZXRcIik7XG5cbkNpcmNsZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgX19leHRlbmRzKENpcmNsZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDaXJjbGUob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgQ2lyY2xlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIENpcmNsZTtcblxufSkoV2lkZ2V0KTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWNpcmNsZS5tYXBcbiovXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2lyY2xlOiByZXF1aXJlKFwiLi9jaXJjbGVcIiksXG4gIFJlY3Q6IHJlcXVpcmUoXCIuL3JlY3RcIilcbn07XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD1leHBvcnRzLm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbnZhciBSZWN0LCBXaWRnZXQsXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuV2lkZ2V0ID0gcmVxdWlyZShcIi4uL3dpZGdldFwiKTtcblxuUmVjdCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgX19leHRlbmRzKFJlY3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUmVjdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBSZWN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIFJlY3Q7XG5cbn0pKFdpZGdldCk7XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD1yZWN0Lm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbnZhciBDb2xvciwgU3ByaXRlLCBXaWRnZXQsXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuV2lkZ2V0ID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xuXG5Db2xvciA9IHJlcXVpcmUoXCIuLi91dGlscy9jb2xvclwiKTtcblxuU3ByaXRlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU3ByaXRlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNwcml0ZShvcHRpb25zKSB7XG4gICAgdmFyIHNlbGY7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBTcHJpdGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICBpZiAoIW9wdGlvbnMuaW1hZ2UpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zcmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZm91bmQgcmVxdWlyZWQgYHNyY2Agb3IgYGltYWdlYCBhdHJpYnV0ZSBpbiBvcHRpb25zLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgdGhpcy5pbWFnZS5zcmMgPSBvcHRpb25zLnNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbWFnZSA9IG9wdGlvbnMuaW1hZ2U7XG4gICAgfVxuICAgIHRoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGYub25fbG9hZC5hcHBseShzZWxmLCBbb3B0aW9ucy53aWR0aCB8fCBmYWxzZSwgb3B0aW9ucy5oZWlnaHQgfHwgZmFsc2VdKTtcbiAgICB9KTtcbiAgfVxuXG4gIFNwcml0ZS5wcm90b3R5cGUub25fbG9hZCA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgaWYgKCF3KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICB9XG4gICAgaWYgKCFoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcbiAgICB9XG4gIH07XG5cbiAgU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICByZXR1cm4gY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3ByaXRlO1xuXG59KShXaWRnZXQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZTtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS5tYXBcbiovXG4iLCIoZnVuY3Rpb24oKXsvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG52YXIgU3RhZ2UsIGNvbnRhaW5lcixcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG5jb250YWluZXIgPSByZXF1aXJlKFwiLi4vdWkvY29udGFpbmVyXCIpO1xuXG4vKlxuU3RhZ2UgY29udGFpbmVyXG5Abm90ZSBHYW1lQ29yZS5leHBvcnRzLnVpLlN0YWdlXG4qL1xuXG5cblN0YWdlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU3RhZ2UsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3RhZ2Uob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgU3RhZ2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy54ID0gb3B0aW9ucy54IHx8IDA7XG4gICAgdGhpcy55ID0gb3B0aW9ucy55IHx8IDA7XG4gICAgdGhpcy5zaGFkZXJzID0gW107XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICBTdGFnZS5wcm90b3R5cGUuYWRkU2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVycy5hcHBlbmQoc2hhZGVyKTtcbiAgfTtcblxuICBTdGFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIGRhdGEsIHNoYWRlciwgX2ksIF9sZW4sIF9yZWY7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgY3R4LmNhbnZhcy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMud2lkdGggfHwgY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgaWYgKHRoaXMuc2hhZGVycykge1xuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICBTdGFnZS5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcywgdGhpcy5jdHgpO1xuICAgICAgX3JlZiA9IHRoaXMuc2hhZGVycztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBzaGFkZXIgPSBfcmVmW19pXTtcbiAgICAgICAgc2hhZGVyLnByb2Nlc3ModGhpcy5jdHgpO1xuICAgICAgfVxuICAgICAgZGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICByZXR1cm4gY3R4LnB1dEltYWdlRGF0YShkYXRhLCB0aGlzLngsIHRoaXMueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTdGFnZS5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcywgY3R4KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN0YWdlO1xuXG59KShjb250YWluZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWdlO1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9c3RhZ2UubWFwXG4qL1xuXG59KSgpIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xudmFyIEJBU0VMSU5FLCBDb2xvciwgREVGQVVMVF9BTElHTiwgREVGQVVMVF9CQVNFTElORSwgREVGQVVMVF9DT0xPUiwgREVGQVVMVF9GT05ULCBGb250LCBUZXh0LCBXaWRnZXQsXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuV2lkZ2V0ID0gcmVxdWlyZShcIi4vd2lkZ2V0XCIpO1xuXG5Db2xvciA9IHJlcXVpcmUoXCIuLi91dGlscy9jb2xvclwiKTtcblxuRm9udCA9IHJlcXVpcmUoXCIuLi91dGlscy9mb250XCIpO1xuXG4vKlxuT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoaXMsIEJBU0VMSU5FXG5Ac3RhdGljXG4qL1xuXG5cbkJBU0VMSU5FID0ge1xuICAvKlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhpcywgQkFTRUxJTkUuVE9QXG4gIEB0eXBlIHtTdHJpbmd9XG4gIEBzdGF0aWNcbiAgKi9cblxuICBUT1A6IFwidG9wXCIsXG4gIC8qXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCBCQVNFTElORS5IQU5HSU5HXG4gIEB0eXBlIHtTdHJpbmd9XG4gIEBzdGF0aWNcbiAgKi9cblxuICBIQU5HSU5HOiBcImhhbmdpbmdcIixcbiAgLypcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoaXMsIEJBU0VMSU5FLk1JRERMRVxuICBAdHlwZSB7U3RyaW5nfVxuICBAc3RhdGljXG4gICovXG5cbiAgTUlERExFOiBcIm1pZGRsZVwiLFxuICAvKlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhpcywgQkFTRUxJTkUuQUxQSEFCRVRJQ1xuICBAdHlwZSB7U3RyaW5nfVxuICBAc3RhdGljXG4gICovXG5cbiAgQUxQSEFCRVRJQzogXCJhbHBoYWJldGljXCIsXG4gIC8qXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLCBCQVNFTElORS5JREVPR1JBUEhJQ1xuICBAdHlwZSB7U3RyaW5nfVxuICBAc3RhdGljXG4gICovXG5cbiAgSURFT0dSQVBISUM6IFwiaWRlb2dyYXBoaWNcIixcbiAgLypcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoaXMsIEJBU0VMSU5FLkJPVFRPTVxuICBAdHlwZSB7U3RyaW5nfVxuICBAc3RhdGljXG4gICovXG5cbiAgQk9UVE9NOiBcImJvdHRvbVwiXG59O1xuXG5ERUZBVUxUX0ZPTlQgPSBuZXcgRm9udCgpO1xuXG5ERUZBVUxUX0NPTE9SID0gbmV3IENvbG9yKFwiYmxhY2tcIik7XG5cbkRFRkFVTFRfQUxJR04gPSBcImxlZnRcIjtcblxuREVGQVVMVF9CQVNFTElORSA9IEJBU0VMSU5FLlRPUDtcblxuLypcbkJhc2UgVGV4dCB3aWRnZXRcbkBub3RlIEdhbWVDb3JlLmV4cG9ydHMudWkuVGV4dFxuKi9cblxuXG5UZXh0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVGV4dCwgX3N1cGVyKTtcblxuICAvKlxuICBAY2xhc3MgVGV4dFxuICBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG4gIFxuICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbnkgYXR0cmlidXRlIG1heSBiZSBpbml0aWFsaXplZCBieSBvcHRpb25cbiAgQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHRdIGRlZmF1bHQgLSBcIlwiXG4gIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb250XSBkZWZhdWx0IC0gXCJOb3JtYWwgMTJweCBWZXJkYW5hXCJcbiAgQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsaWduXSBkZWZhdWx0IC0gXCJsZWZ0XCJcbiAgQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJhc2VsaW5lXSBkZWZhdWx0IC0gSm95LlRleHQuQkFTRUxJTkUuVE9QXG4gIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb2xvcl0gZGVmYXVsdCAtICMwMDAwMDBcbiAgXG4gIEBjb25zdHJ1Y3RvclxuICAqL1xuXG5cbiAgZnVuY3Rpb24gVGV4dChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBUZXh0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIC8qXG4gICAgVGV4dCB0byBiZSBkaXNwbGF5ZWRcbiAgICBAYXR0cmlidXRlIHRleHRcbiAgICBAZGVmYXVsdCBcIlwiXG4gICAgQHR5cGUge1N0cmluZ31cbiAgICAqL1xuXG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0IHx8IFwiXCI7XG4gICAgLypcbiAgICBGb250IGZhbWlseSBhbmQgc2l6ZVxuICAgIEBhdHRyaWJ1dGUgZm9udFxuICAgIEBkZWZhdWx0IFwiTm9ybWFsIDEycHggVmVyZGFuYVwiXG4gICAgQHR5cGUge1N0cmluZ31cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmb250Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mb250KSB7XG4gICAgICAgICAgdGhpcy5mb250ID0gb3B0aW9ucy5mb250IHx8IERFRkFVTFRfRk9OVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgICAgdGhpcy5fZm9udCA9IGZvbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbWVhc3VyZSA9IFRleHQuTWVhc3VyZVRleHQodGhpcy50ZXh0LCB0aGlzLl9mb250KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKlxuICAgIFRleHQgaG9yaXpvbnRhbCBhbGlnbm1lbnRcbiAgICBAYXR0cmlidXRlIGFsaWduXG4gICAgQGRlZmF1bHQgXCJsZWZ0XCJcbiAgICBAdHlwZSB7U3RyaW5nfVxuICAgICovXG5cbiAgICB0aGlzLmFsaWduID0gb3B0aW9ucy5hbGlnbiB8fCBERUZBVUxUX0FMSUdOO1xuICAgIC8qXG4gICAgVGV4dCB2ZXJ0aWNhbCBiYXNlbGluZVxuICAgIEBhdHRyaWJ1dGUgYmFzZWxpbmVcbiAgICBAZGVmYXVsdCBKb3kuVGV4dC5CQVNFTElORS5UT1BcbiAgICBAdHlwZSB7U3RyaW5nfVxuICAgICovXG5cbiAgICB0aGlzLmJhc2VsaW5lID0gb3B0aW9ucy5iYXNlbGluZSB8fCBERUZBVUxUX0JBU0VMSU5FO1xuICAgIC8qXG4gICAgQ29sb3Igb2YgdGhlIHRleHRcbiAgICBAYXR0cmlidXRlIGNvbG9yXG4gICAgQGRlZmF1bHQgXCIjMDAwMDAwXCJcbiAgICBAdHlwZSB7U3RyaW5nLCBDb2xvcn1cbiAgICAqL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29sb3JcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb2xvcikge1xuICAgICAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8IERFRkFVTFRfQ09MT1I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY29sb3IgPSB0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIgPyBuZXcgQ29sb3IoY29sb3IpIDogY29sb3I7XG4gICAgICAgIHJldHVybiB0aGlzLmFscGhhID0gdGhpcy5fY29sb3IuYTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5zdHJva2UpIHtcbiAgICAgIHRoaXMudXNlU3Ryb2tlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXNlRmlsbCgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19tZWFzdXJlKSB7XG4gICAgICAgICAgdGhpcy5fX21lYXN1cmUgPSBUZXh0Lk1lYXN1cmVUZXh0KHRoaXMudGV4dCwgdGhpcy5mb250KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX21lYXN1cmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX21lYXN1cmUud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fbWVhc3VyZSkge1xuICAgICAgICAgIHRoaXMuX19tZWFzdXJlID0gVGV4dC5NZWFzdXJlVGV4dCh0aGlzLnRleHQsIHRoaXMuZm9udCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX19tZWFzdXJlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19tZWFzdXJlLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLypcbiAgQG1ldGhvZCB1c2VTdHJva2VcbiAgKi9cblxuXG4gIFRleHQucHJvdG90eXBlLnVzZVN0cm9rZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3Ryb2tlID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxNZXRob2QgPSBcInN0cm9rZVRleHRcIjtcbiAgICByZXR1cm4gdGhpcy5zdHlsZU1ldGhvZCA9IFwic3Ryb2tlU3R5bGVcIjtcbiAgfTtcblxuICAvKlxuICBAbWV0aG9kIHVzZUZpbGxcbiAgKi9cblxuXG4gIFRleHQucHJvdG90eXBlLnVzZUZpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0cm9rZSA9IGZhbHNlO1xuICAgIHRoaXMuZmlsbE1ldGhvZCA9IFwiZmlsbFRleHRcIjtcbiAgICByZXR1cm4gdGhpcy5zdHlsZU1ldGhvZCA9IFwiZmlsbFN0eWxlXCI7XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIGN0eC5mb250ID0gdGhpcy5mb250LnRvU3RyaW5nKCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHRoaXMuYWxpZ247XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuYmFzZWxpbmU7XG4gICAgY3R4W3RoaXMuc3R5bGVNZXRob2RdID0gdGhpcy5jb2xvci50b1N0cmluZygpO1xuICAgIGN0eFt0aGlzLmZpbGxNZXRob2RdKHRoaXMudGV4dCwgMCwgMCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWVhc3VyZShjdHgpO1xuICB9O1xuXG4gIC8qXG4gIEBtZXRob2QgZ2V0TWVhc3VyZVxuICBAcmV0dXJuIHtUZXh0TWV0cmljc30gdGV4dCBtZXRyaWNzXG4gICovXG5cblxuICBUZXh0LnByb3RvdHlwZS5nZXRNZWFzdXJlID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIG07XG4gICAgdGhpcy5fX21lYXN1cmUgPSB7fTtcbiAgICBtID0gVGV4dC5NZWFzdXJlVGV4dCh0aGlzLnRleHQsIHRoaXMuZm9udCk7XG4gICAgdGhpcy5fX21lYXN1cmUud2lkdGggPSBtWzBdO1xuICAgIHJldHVybiB0aGlzLl9fbWVhc3VyZS5oZWlnaHQgPSBtWzFdO1xuICB9O1xuXG4gIFRleHQuQkFTRUxJTkUgPSBCQVNFTElORTtcblxuICBUZXh0Lk1lYXN1cmVUZXh0ID0gZnVuY3Rpb24odGV4dCwgZm9udCkge1xuICAgIHZhciBkaXYsIHNpemUsIHN0cjtcbiAgICBzdHIgPSB0ZXh0ICsgXCI6XCIgKyBmb250O1xuICAgIGlmICh0eXBlb2YgdGhpcy5fX21lYXN1cmV0ZXh0X2NhY2hlX18gPT09IFwib2JqZWN0XCIgJiYgdGhpcy5fX21lYXN1cmV0ZXh0X2NhY2hlX19bc3RyXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19tZWFzdXJldGV4dF9jYWNoZV9fW3N0cl07XG4gICAgfVxuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgZGl2LmlubmVySFRNTCA9IHRleHQ7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBcIi0xMDBweFwiO1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gXCItMTAwcHhcIjtcbiAgICBkaXYuc3R5bGUuZm9udCA9IGZvbnQudG9TdHJpbmcoKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgc2l6ZSA9IFtkaXYub2Zmc2V0V2lkdGgsIGRpdi5vZmZzZXRIZWlnaHRdO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICBpZiAodHlwZW9mIHRoaXMuX19tZWFzdXJldGV4dF9jYWNoZV9fICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLl9fbWVhc3VyZXRleHRfY2FjaGVfXyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLl9fbWVhc3VyZXRleHRfY2FjaGVfX1tzdHJdID0gc2l6ZTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcblxuICByZXR1cm4gVGV4dDtcblxufSkoV2lkZ2V0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC5tYXBcbiovXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4zXG52YXIgQ29sb3IsIE1hdHJpeDJkLCBTdXBwb3J0LCBUcmlnZ2VyYWJsZSwgVVVJRCwgVmVjdG9yMmQsIFdpZGdldCxcbiAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG5VVUlEID0gcmVxdWlyZShcIi4uL21hdGgvdXVpZFwiKTtcblxuVHJpZ2dlcmFibGUgPSByZXF1aXJlKFwiLi4vY29yZS90cmlnZ2VyYWJsZVwiKTtcblxuVmVjdG9yMmQgPSByZXF1aXJlKFwiLi4vbWF0aC92ZWN0b3IyZFwiKTtcblxuTWF0cml4MmQgPSByZXF1aXJlKFwiLi4vbWF0aC9tYXRyaXgyZFwiKTtcblxuU3VwcG9ydCA9IHJlcXVpcmUoXCIuLi9jb3JlL3N1cHBvcnRcIik7XG5cbkNvbG9yID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbG9yXCIpO1xuXG4vKlxuQmFzZSByZW5kZXJhYmxlIGVsZW1lbnRcblxuQG5vdGUgR2FtZUNvcmUuZXhwb3J0cy51aS5XaWRnZXRcbiovXG5cblxuV2lkZ2V0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICBfX2V4dGVuZHMoV2lkZ2V0LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFdpZGdldChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmlkID0gVVVJRC5nZW5lcmF0ZVVuaXF1ZUlkKCk7XG4gICAgV2lkZ2V0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIC8qXG4gICAgQGF0dHJpYnV0ZSBwaXZvdFxuICAgIEB0eXBlIHtWZWN0b3IyZH1cbiAgICBAZGVmYXVsdCAwLDBcbiAgICAqL1xuXG4gICAgdGhpcy5waXZvdCA9IG9wdGlvbnMucGl2b3QgfHwgbmV3IFZlY3RvcjJkKG9wdGlvbnMucGl2b3RYIHx8IDAsIG9wdGlvbnMucGl2b3RZIHx8IDApO1xuICAgIC8qXG4gICAgQGF0dHJpYnV0ZSBza2V3WFxuICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgQGRlZmF1bHQgMFxuICAgICovXG5cbiAgICB0aGlzLnNrZXcgPSBvcHRpb25zLnNrZXcgfHwgbmV3IFZlY3RvcjJkKG9wdGlvbnMuc2tld1ggfHwgMCwgb3B0aW9ucy5za2V3WSB8fCAwKTtcbiAgICAvKlxuICAgIEBhdHRyaWJ1dGUgc2NhbGVcbiAgICBAdHlwZSB7VmVjdG9yMmR9XG4gICAgQGRlZmF1bHQgMSwxXG4gICAgKi9cblxuICAgIHRoaXMuc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IG5ldyBWZWN0b3IyZChvcHRpb25zLnNjYWxlWCB8fCAxLCBvcHRpb25zLnNjYWxlWSB8fCAxKTtcbiAgICAvKlxuICAgIEBhdHRyaWJ1dGUgYWxwaGFcbiAgICBAdHlwZSB7TnVtYmVyfVxuICAgIEBkZWZhdWx0IDFcbiAgICAqL1xuXG4gICAgdGhpcy5hbHBoYSA9ICh0eXBlb2Ygb3B0aW9ucy5hbHBoYSA9PT0gXCJ1bmRlZmluZWRcIiA/IDEgOiBvcHRpb25zLmFscGhhKTtcbiAgICAvKlxuICAgIEBhdHRyaWJ1dGUgcm90YXRpb25cbiAgICBAdHlwZSB7TnVtYmVyfVxuICAgIEBkZWZhdWx0IDBcbiAgICAqL1xuXG4gICAgdGhpcy5yb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb24gfHwgMDtcbiAgICAvKlxuICAgIEBhdHRyaWJ1dGUgc21vb3RoXG4gICAgQHR5cGUge0Jvb2xlYW59XG4gICAgQGRlZmF1bHQgZmFsc2VcbiAgICAqL1xuXG4gICAgdGhpcy5zbW9vdGggPSAodHlwZW9mIG9wdGlvbnMuc21vb3RoID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IG9wdGlvbnMuc21vb3RoKTtcbiAgICB0aGlzLl9tYXRyaXggPSBNYXRyaXgyZC5pZGVudGl0eS5jbG9uZSgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvc2l0aW9uXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fcG9zaXRpb24pIHtcbiAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWN0b3IyZCgwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uID0gdmVjdG9yLmNsb25lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieFwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54IHx8IDA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnggPSB4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLngpIHtcbiAgICAgIHRoaXMueCA9IG9wdGlvbnMueDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55IHx8IDA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnkgPSB5O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnkpIHtcbiAgICAgIHRoaXMueSA9IG9wdGlvbnMueTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoIHx8IDA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aCA9IHc7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodCB8fCAwO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0ID0gaDtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmVudFwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8ICd1bmRlZmluZWQnO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5hZGRDaGlsZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpc2libGVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxwaGEgPD0gMCB8fCAhdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZpc2liaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGUgPSBCb29sZWFuKHZpc2liaWxpdHkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudmlzaWJsZSA9IChvcHRpb25zLnZpc2libGUgPyBvcHRpb25zLnZpc2libGUgOiB2b2lkIDApIHx8IHRydWU7XG4gIH1cblxuICBXaWRnZXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBiaXQsIG10eDtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBiaXQgPSB7XG4gICAgICBcImZhbHNlXCI6IC0xLFxuICAgICAgXCJ0cnVlXCI6IDFcbiAgICB9O1xuICAgIG10eCA9IE1hdHJpeDJkLmlkZW50aXR5LmFwcGVuZFRyYW5zZm9ybSh0aGlzLnBvc2l0aW9uLnggKyB0aGlzLndpZHRoICogKHRoaXMuZmxpcFggKyAwKSwgdGhpcy5wb3NpdGlvbi55ICsgdGhpcy5oZWlnaHQgKiAodGhpcy5mbGlwWSArIDApLCB0aGlzLnNjYWxlLnggKiBiaXRbIXRoaXMuZmxpcFhdLCB0aGlzLnNjYWxlLnkgKiBiaXRbIXRoaXMuZmxpcFldLCB0aGlzLnJvdGF0aW9uLCB0aGlzLnNrZXcueCwgdGhpcy5za2V3LnksIHRoaXMucGl2b3QueCwgdGhpcy5waXZvdC55KTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xuICAgIGN0eC50cmFuc2Zvcm0obXR4Lm0xMSwgbXR4Lm0xMiwgbXR4Lm0yMSwgbXR4Lm0yMiwgbXR4LmR4LCBtdHguZHkpO1xuICAgIGN0eC5yb3RhdGUoMC4wMTc0NTMyOTI1ICogdGhpcy5yb3RhdGlvbik7XG4gICAgY3R4LnNldEFscGhhKHRoaXMuYWxwaGEpO1xuICAgIGlmICh0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbikge1xuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIH1cbiAgICBjdHguc2V0QWxwaGEodGhpcy5hbHBoYSk7XG4gICAgaWYgKHRoaXMuX3JlbmRlcikge1xuICAgICAgdGhpcy5fcmVuZGVyKGN0eCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZSgxIC8gdGhpcy5zY2FsZS54LCAxIC8gdGhpcy5zY2FsZS55KTtcbiAgICBjdHgudHJhbnNsYXRlKC10aGlzLnBvc2l0aW9uLngsIC10aGlzLnBvc2l0aW9uLnkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gY3R4LnJlc3RvcmUoKTtcbiAgfTtcblxuICByZXR1cm4gV2lkZ2V0O1xuXG59KShUcmlnZ2VyYWJsZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0O1xuXG4vKlxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9d2lkZ2V0Lm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbi8qXG5JbnNwaXJlZCBieSBUaW55Q29sb3JcbkBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9UaW55Q29sb3JcbiovXG5cbnZhciBDT0xPUl9OQU1FUywgQ09MT1JfTkFNRVNfRiwgQ1NTX0lOVEVHRVIsIENTU19OVU1CRVIsIENTU19VTklULCBDb2xvciwgTWF0aGVtYXRpYywgUEVSTUlTU0lWRV9NQVRDSDMsIFBFUk1JU1NJVkVfTUFUQ0g0LCBib3VuZDAxLCBjb252ZXJ0VG9QZXJjZW50YWdlLCBmbGlwLCBpc09uZVBvaW50WmVybywgaXNQZXJjZW50YWdlLCBtYXRjaGVycywgcGFkMiwgcGFyc2VIZXgsIHN0cmluZ0lucHV0VG9PYmplY3QsIHRyaW1MZWZ0LCB0cmltUmlnaHQ7XG5cbk1hdGhlbWF0aWMgPSByZXF1aXJlKFwiLi4vbWF0aC9tYXRoXCIpO1xuXG4vKlxuKi9cblxuXG5DT0xPUl9OQU1FUyA9IHtcbiAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuICBhbnRpcXVld2hpdGU6IFwiZmFlYmQ3XCIsXG4gIGFxdWE6IFwiMGZmXCIsXG4gIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG4gIGF6dXJlOiBcImYwZmZmZlwiLFxuICBiZWlnZTogXCJmNWY1ZGNcIixcbiAgYmlzcXVlOiBcImZmZTRjNFwiLFxuICBibGFjazogXCIwMDBcIixcbiAgYmxhbmNoZWRhbG1vbmQ6IFwiZmZlYmNkXCIsXG4gIGJsdWU6IFwiMDBmXCIsXG4gIGJsdWV2aW9sZXQ6IFwiOGEyYmUyXCIsXG4gIGJyb3duOiBcImE1MmEyYVwiLFxuICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gIGJ1cm50c2llbm5hOiBcImVhN2U1ZFwiLFxuICBjYWRldGJsdWU6IFwiNWY5ZWEwXCIsXG4gIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG4gIGNob2NvbGF0ZTogXCJkMjY5MWVcIixcbiAgY29yYWw6IFwiZmY3ZjUwXCIsXG4gIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuICBjb3Juc2lsazogXCJmZmY4ZGNcIixcbiAgY3JpbXNvbjogXCJkYzE0M2NcIixcbiAgY3lhbjogXCIwZmZcIixcbiAgZGFya2JsdWU6IFwiMDAwMDhiXCIsXG4gIGRhcmtjeWFuOiBcIjAwOGI4YlwiLFxuICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuICBkYXJrZ3JheTogXCJhOWE5YTlcIixcbiAgZGFya2dyZWVuOiBcIjAwNjQwMFwiLFxuICBkYXJrZ3JleTogXCJhOWE5YTlcIixcbiAgZGFya2toYWtpOiBcImJkYjc2YlwiLFxuICBkYXJrbWFnZW50YTogXCI4YjAwOGJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG4gIGRhcmtvcmFuZ2U6IFwiZmY4YzAwXCIsXG4gIGRhcmtvcmNoaWQ6IFwiOTkzMmNjXCIsXG4gIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG4gIGRhcmtzYWxtb246IFwiZTk5NjdhXCIsXG4gIGRhcmtzZWFncmVlbjogXCI4ZmJjOGZcIixcbiAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcbiAgZGFya3NsYXRlZ3JheTogXCIyZjRmNGZcIixcbiAgZGFya3NsYXRlZ3JleTogXCIyZjRmNGZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcbiAgZGFya3Zpb2xldDogXCI5NDAwZDNcIixcbiAgZGVlcHBpbms6IFwiZmYxNDkzXCIsXG4gIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuICBkaW1ncmF5OiBcIjY5Njk2OVwiLFxuICBkaW1ncmV5OiBcIjY5Njk2OVwiLFxuICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuICBmaXJlYnJpY2s6IFwiYjIyMjIyXCIsXG4gIGZsb3JhbHdoaXRlOiBcImZmZmFmMFwiLFxuICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcbiAgZnVjaHNpYTogXCJmMGZcIixcbiAgZ2FpbnNib3JvOiBcImRjZGNkY1wiLFxuICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuICBnb2xkOiBcImZmZDcwMFwiLFxuICBnb2xkZW5yb2Q6IFwiZGFhNTIwXCIsXG4gIGdyYXk6IFwiODA4MDgwXCIsXG4gIGdyZWVuOiBcIjAwODAwMFwiLFxuICBncmVlbnllbGxvdzogXCJhZGZmMmZcIixcbiAgZ3JleTogXCI4MDgwODBcIixcbiAgaG9uZXlkZXc6IFwiZjBmZmYwXCIsXG4gIGhvdHBpbms6IFwiZmY2OWI0XCIsXG4gIGluZGlhbnJlZDogXCJjZDVjNWNcIixcbiAgaW5kaWdvOiBcIjRiMDA4MlwiLFxuICBpdm9yeTogXCJmZmZmZjBcIixcbiAga2hha2k6IFwiZjBlNjhjXCIsXG4gIGxhdmVuZGVyOiBcImU2ZTZmYVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcImZmZjBmNVwiLFxuICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG4gIGxlbW9uY2hpZmZvbjogXCJmZmZhY2RcIixcbiAgbGlnaHRibHVlOiBcImFkZDhlNlwiLFxuICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuICBsaWdodGN5YW46IFwiZTBmZmZmXCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcImZhZmFkMlwiLFxuICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG4gIGxpZ2h0Z3JlZW46IFwiOTBlZTkwXCIsXG4gIGxpZ2h0Z3JleTogXCJkM2QzZDNcIixcbiAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuICBsaWdodHNhbG1vbjogXCJmZmEwN2FcIixcbiAgbGlnaHRzZWFncmVlbjogXCIyMGIyYWFcIixcbiAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuICBsaWdodHNsYXRlZ3JheTogXCI3ODlcIixcbiAgbGlnaHRzbGF0ZWdyZXk6IFwiNzg5XCIsXG4gIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuICBsaWdodHllbGxvdzogXCJmZmZmZTBcIixcbiAgbGltZTogXCIwZjBcIixcbiAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuICBsaW5lbjogXCJmYWYwZTZcIixcbiAgbWFnZW50YTogXCJmMGZcIixcbiAgbWFyb29uOiBcIjgwMDAwMFwiLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBcIjY2Y2RhYVwiLFxuICBtZWRpdW1ibHVlOiBcIjAwMDBjZFwiLFxuICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG4gIG1lZGl1bXB1cnBsZTogXCI5MzcwZGJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiM2NiMzcxXCIsXG4gIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiMDBmYTlhXCIsXG4gIG1lZGl1bXR1cnF1b2lzZTogXCI0OGQxY2NcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuICBtaWRuaWdodGJsdWU6IFwiMTkxOTcwXCIsXG4gIG1pbnRjcmVhbTogXCJmNWZmZmFcIixcbiAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuICBtb2NjYXNpbjogXCJmZmU0YjVcIixcbiAgbmF2YWpvd2hpdGU6IFwiZmZkZWFkXCIsXG4gIG5hdnk6IFwiMDAwMDgwXCIsXG4gIG9sZGxhY2U6IFwiZmRmNWU2XCIsXG4gIG9saXZlOiBcIjgwODAwMFwiLFxuICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG4gIG9yYW5nZTogXCJmZmE1MDBcIixcbiAgb3JhbmdlcmVkOiBcImZmNDUwMFwiLFxuICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG4gIHBhbGVnb2xkZW5yb2Q6IFwiZWVlOGFhXCIsXG4gIHBhbGVncmVlbjogXCI5OGZiOThcIixcbiAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcbiAgcGFsZXZpb2xldHJlZDogXCJkYjcwOTNcIixcbiAgcGFwYXlhd2hpcDogXCJmZmVmZDVcIixcbiAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuICBwZXJ1OiBcImNkODUzZlwiLFxuICBwaW5rOiBcImZmYzBjYlwiLFxuICBwbHVtOiBcImRkYTBkZFwiLFxuICBwb3dkZXJibHVlOiBcImIwZTBlNlwiLFxuICBwdXJwbGU6IFwiODAwMDgwXCIsXG4gIHJlZDogXCJmMDBcIixcbiAgcm9zeWJyb3duOiBcImJjOGY4ZlwiLFxuICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG4gIHNhZGRsZWJyb3duOiBcIjhiNDUxM1wiLFxuICBzYWxtb246IFwiZmE4MDcyXCIsXG4gIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG4gIHNlYWdyZWVuOiBcIjJlOGI1N1wiLFxuICBzZWFzaGVsbDogXCJmZmY1ZWVcIixcbiAgc2llbm5hOiBcImEwNTIyZFwiLFxuICBzaWx2ZXI6IFwiYzBjMGMwXCIsXG4gIHNreWJsdWU6IFwiODdjZWViXCIsXG4gIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcbiAgc2xhdGVncmF5OiBcIjcwODA5MFwiLFxuICBzbGF0ZWdyZXk6IFwiNzA4MDkwXCIsXG4gIHNub3c6IFwiZmZmYWZhXCIsXG4gIHNwcmluZ2dyZWVuOiBcIjAwZmY3ZlwiLFxuICBzdGVlbGJsdWU6IFwiNDY4MmI0XCIsXG4gIHRhbjogXCJkMmI0OGNcIixcbiAgdGVhbDogXCIwMDgwODBcIixcbiAgdGhpc3RsZTogXCJkOGJmZDhcIixcbiAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICB0dXJxdW9pc2U6IFwiNDBlMGQwXCIsXG4gIHZpb2xldDogXCJlZTgyZWVcIixcbiAgd2hlYXQ6IFwiZjVkZWIzXCIsXG4gIHdoaXRlOiBcImZmZlwiLFxuICB3aGl0ZXNtb2tlOiBcImY1ZjVmNVwiLFxuICB5ZWxsb3c6IFwiZmYwXCIsXG4gIHllbGxvd2dyZWVuOiBcIjlhY2QzMlwiXG59O1xuXG50cmltTGVmdCA9IC9eW1xccywjXSsvO1xuXG50cmltUmlnaHQgPSAvXFxzKyQvO1xuXG5mbGlwID0gZnVuY3Rpb24obykge1xuICB2YXIgZmxpcHBlZCwgaywgdjtcbiAgZmxpcHBlZCA9IHt9O1xuICBmb3IgKGsgaW4gbykge1xuICAgIHYgPSBvW2tdO1xuICAgIGZsaXBwZWRbdl0gPSBrO1xuICB9XG4gIHJldHVybiBmbGlwcGVkO1xufTtcblxuYm91bmQwMSA9IGZ1bmN0aW9uKG4sIG1heCkge1xuICB2YXIgcHJvY2Vzc1BlcmNlbnQ7XG4gIGlmIChpc09uZVBvaW50WmVybyhuKSkge1xuICAgIG4gPSBcIjEwMCVcIjtcbiAgfVxuICBwcm9jZXNzUGVyY2VudCA9IGlzUGVyY2VudGFnZShuKTtcbiAgbiA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgcGFyc2VGbG9hdChuKSkpO1xuICBpZiAocHJvY2Vzc1BlcmNlbnQpIHtcbiAgICBuID0gcGFyc2VJbnQobiAqIG1heCwgMTApIC8gMTAwO1xuICB9XG4gIGlmIChNYXRoLmFicyhuIC0gbWF4KSA8IDAuMDAwMDAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIChuICUgbWF4KSAvIHBhcnNlRmxvYXQobWF4KTtcbn07XG5cbnBhcnNlSGV4ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDE2KTtcbn07XG5cbmlzT25lUG9pbnRaZXJvID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKFwiLlwiKSAhPT0gLTEgJiYgcGFyc2VGbG9hdChuKSA9PT0gMTtcbn07XG5cbmlzUGVyY2VudGFnZSA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBuID09PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZihcIiVcIikgIT09IC0xO1xufTtcblxucGFkMiA9IGZ1bmN0aW9uKGMpIHtcbiAgaWYgKGMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIFwiMFwiICsgYztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIiArIGM7XG4gIH1cbn07XG5cbmNvbnZlcnRUb1BlcmNlbnRhZ2UgPSBmdW5jdGlvbihuKSB7XG4gIGlmIChuIDw9IDEpIHtcbiAgICBuID0gKG4gKiAxMDApICsgXCIlXCI7XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuXG5DT0xPUl9OQU1FU19GID0gZmxpcChDT0xPUl9OQU1FUyk7XG5cbkNTU19JTlRFR0VSID0gXCJbLVxcXFwrXT9cXFxcZCslP1wiO1xuXG5DU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG5cbkNTU19VTklUID0gXCIoPzpcIiArIENTU19OVU1CRVIgKyBcIil8KD86XCIgKyBDU1NfSU5URUdFUiArIFwiKVwiO1xuXG5QRVJNSVNTSVZFX01BVENIMyA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuXG5QRVJNSVNTSVZFX01BVENINCA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuXG5tYXRjaGVycyA9IHtcbiAgcmdiOiBuZXcgUmVnRXhwKFwicmdiXCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gIHJnYmE6IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gIGhzbDogbmV3IFJlZ0V4cChcImhzbFwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICBoc2xhOiBuZXcgUmVnRXhwKFwiaHNsYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICBoc3Y6IG5ldyBSZWdFeHAoXCJoc3ZcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgaGV4MzogL14oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgaGV4NjogL14oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkL1xufTtcblxuLypcbkNvbG9yIG9wZXJhdGlvbnNcblxuQG5vdGUgR2FtZUNvcmUuZXhwb3J0cy51dGlscy5Db2xvclxuKi9cblxuXG5Db2xvciA9IChmdW5jdGlvbigpIHtcbiAgLypcbiAgQHBhcmFtIHtTdHJpbmcgfCBDb2xvcn0gaGV4IGNvbG9yIHN0cmluZyBvciBjb2xvciBuYW1lIG9yIENvbG9yIGluc3RhbmNlXG4gIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICovXG5cbiAgZnVuY3Rpb24gQ29sb3Iob3B0aW9ucykge1xuICAgIHZhciBjb2xvciwgZm9ybWF0LCByZ2I7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb2xvciA9ICFvcHRpb25zLmNvbG9yID8gb3B0aW9ucyA6IG9wdGlvbnMuY29sb3IgfHwgJ2JsYWNrJztcbiAgICByZ2IgPSBDb2xvci5pbnB1dFRvUkdCKGNvbG9yKTtcbiAgICB0aGlzLnIgPSByZ2IucjtcbiAgICB0aGlzLmcgPSByZ2IuZztcbiAgICB0aGlzLmIgPSByZ2IuYjtcbiAgICB0aGlzLmEgPSBvcHRpb25zLmFscGhhIHx8IHJnYi5hO1xuICAgIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IHJnYi5mb3JtYXQgfHwgZmFsc2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm91bmRBXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKDEwMCAqIHRoaXMuYSkgLyAxMDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuciA8IDEpIHtcbiAgICAgIHRoaXMuciA9IE1hdGgucm91bmQodGhpcy5yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZyA8IDEpIHtcbiAgICAgIHRoaXMuZyA9IE1hdGgucm91bmQodGhpcy5nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYiA8IDEpIHtcbiAgICAgIHRoaXMuYiA9IE1hdGgucm91bmQodGhpcy5iKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICBAbWV0aG9kIHRvSHN2XG4gIEByZXR1cm4ge09iamVjdH0ge2gscyx2LGF9XG4gICovXG5cblxuICBDb2xvci5wcm90b3R5cGUudG9Ic3YgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaHN2O1xuICAgIGhzdiA9IENvbG9yLnJnYlRvSHN2KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgIHJldHVybiB7XG4gICAgICBoOiBoc3YuaCAqIDM2MCxcbiAgICAgIHM6IGhzdi5zLFxuICAgICAgdjogaHN2LnYsXG4gICAgICBhOiB0aGlzLmFcbiAgICB9O1xuICB9O1xuXG4gIC8qXG4gIEBtZXRob2QgdG9Ic3ZTdHJpbmdcbiAgQHJldHVybiB7U3RyaW5nfVxuICAqL1xuXG5cbiAgQ29sb3IucHJvdG90eXBlLnRvSHN2U3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGgsIGhzdiwgcywgdjtcbiAgICBoc3YgPSBDb2xvci5yZ2JUb0hzdih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICBoID0gTWF0aC5yb3VuZChoc3YuaCAqIDM2MCk7XG4gICAgcyA9IE1hdGgucm91bmQoaHN2LnMgKiAxMDApO1xuICAgIHYgPSBNYXRoLnJvdW5kKGhzdi52ICogMTAwKTtcbiAgICBpZiAodGhpcy5hID09PSAxKSB7XG4gICAgICByZXR1cm4gXCJoc3YoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJoc3ZhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdiArIFwiJSwgXCIgKyB0aGlzLnJvdW5kQSArIFwiKVwiO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICBAbWV0aG9kIHRvSHNsXG4gIEByZXR1cm4ge09iamVjdH0ge2gscyxsLGF9XG4gICovXG5cblxuICBDb2xvci5wcm90b3R5cGUudG9Ic2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaHNsO1xuICAgIGhzbCA9IENvbG9yLnJnYlRvSHNsKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgIHJldHVybiB7XG4gICAgICBoOiBoc2wuaCAqIDM2MCxcbiAgICAgIHM6IGhzbC5zLFxuICAgICAgbDogaHNsLmwsXG4gICAgICBhOiB0aGlzLmFcbiAgICB9O1xuICB9O1xuXG4gIC8qXG4gIEBtZXRob2QgdG9Ic2xTdHJpbmdcbiAgQHJldHVybiB7U3RyaW5nfVxuICAqL1xuXG5cbiAgQ29sb3IucHJvdG90eXBlLnRvSHNsU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGgsIGhzbCwgbCwgcztcbiAgICBoc2wgPSBDb2xvci5yZ2JUb0hzbCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICBoID0gTWF0aC5yb3VuZChoc2wuaCAqIDM2MCk7XG4gICAgcyA9IE1hdGgucm91bmQoaHNsLnMgKiAxMDApO1xuICAgIGwgPSBNYXRoLnJvdW5kKGhzbC5sICogMTAwKTtcbiAgICBpZiAodGhpcy5hID09PSAxKSB7XG4gICAgICByZXR1cm4gXCJoc2woXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJoc2xhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgbCArIFwiJSwgXCIgKyB0aGlzLnJvdW5kQSArIFwiKVwiO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICBAbWV0aG9kIHRvSGV4XG4gIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3czQ2hhciBkZWZhdWx0cz1mYWxzZVxuICBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5cblxuICBDb2xvci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgaWYgKGFsbG93M0NoYXIgPT0gbnVsbCkge1xuICAgICAgYWxsb3czQ2hhciA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gQ29sb3IucmdiVG9IZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgYWxsb3czQ2hhcik7XG4gIH07XG5cbiAgLypcbiAgQG1ldGhvZCB0b0hleFN0cmluZ1xuICBAcGFyYW0ge0Jvb2xlYW59IGFsbG93M0NoYXIgZGVmYXVsdHM9ZmFsc2VcbiAgQHJldHVybiB7U3RyaW5nfSAjICsgdG9IZXgoKVxuICAqL1xuXG5cbiAgQ29sb3IucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgIGlmIChhbGxvdzNDaGFyID09IG51bGwpIHtcbiAgICAgIGFsbG93M0NoYXIgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFwiI1wiICsgdGhpcy50b0hleChhbGxvdzNDaGFyKTtcbiAgfTtcblxuICAvKlxuICBAbWV0aG9kIHRvUmdiXG4gIEByZXR1cm4ge09iamVjdH0ge3IsZyxiLGF9XG4gICovXG5cblxuICBDb2xvci5wcm90b3R5cGUudG9SZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogTWF0aC5yb3VuZCh0aGlzLnIpLFxuICAgICAgZzogTWF0aC5yb3VuZCh0aGlzLmcpLFxuICAgICAgYjogTWF0aC5yb3VuZCh0aGlzLmIpLFxuICAgICAgYTogdGhpcy5hXG4gICAgfTtcbiAgfTtcblxuICAvKlxuICBAbWV0aG9kIHRvUmdiU3RyaW5nXG4gIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cblxuXG4gIENvbG9yLnByb3RvdHlwZS50b1JnYlN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmEgPT09IDEpIHtcbiAgICAgIHJldHVybiBcInJnYihcIiArIE1hdGgucm91bmQodGhpcy5yKSArIFwiLCBcIiArIE1hdGgucm91bmQodGhpcy5nKSArIFwiLCBcIiArIE1hdGgucm91bmQodGhpcy5iKSArIFwiKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgTWF0aC5yb3VuZCh0aGlzLnIpICsgXCIsIFwiICsgTWF0aC5yb3VuZCh0aGlzLmcpICsgXCIsIFwiICsgTWF0aC5yb3VuZCh0aGlzLmIpICsgXCIsIFwiICsgdGhpcy5yb3VuZEEgKyBcIilcIjtcbiAgICB9XG4gIH07XG5cbiAgQ29sb3IucHJvdG90eXBlLnRvUGVyY2VudGFnZVJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICByOiBNYXRoLnJvdW5kKGJvdW5kMDEodGhpcy5yLCAyNTUpICogMTAwKSArIFwiJVwiLFxuICAgICAgZzogTWF0aC5yb3VuZChib3VuZDAxKHRoaXMuZywgMjU1KSAqIDEwMCkgKyBcIiVcIixcbiAgICAgIGI6IE1hdGgucm91bmQoYm91bmQwMSh0aGlzLmIsIDI1NSkgKiAxMDApICsgXCIlXCIsXG4gICAgICBhOiB0aGlzLmFcbiAgICB9O1xuICB9O1xuXG4gIENvbG9yLnByb3RvdHlwZS50b1BlcmNlbnRhZ2VSZ2JTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hID09PSAxKSB7XG4gICAgICByZXR1cm4gXCJyZ2IoXCIgKyBNYXRoLnJvdW5kKGJvdW5kMDEodGhpcy5yLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBNYXRoLnJvdW5kKGJvdW5kMDEodGhpcy5nLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBNYXRoLnJvdW5kKGJvdW5kMDEodGhpcy5iLCAyNTUpICogMTAwKSArIFwiJSlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwicmdiYShcIiArIE1hdGgucm91bmQoYm91bmQwMSh0aGlzLnIsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIE1hdGgucm91bmQoYm91bmQwMSh0aGlzLmcsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIE1hdGgucm91bmQoYm91bmQwMSh0aGlzLmIsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIHRoaXMuYSArIFwiKVwiO1xuICAgIH1cbiAgfTtcblxuICBDb2xvci5wcm90b3R5cGUudG9OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICB9XG4gICAgcmV0dXJuIENPTE9SX05BTUVTX0ZbQ29sb3IucmdiVG9IZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdHJ1ZSldIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qXG4gIE91dHB1dGluZyBjdXJyZW50IGNvbG9yIGFzIHN0cmluZ1xuICAqL1xuXG5cbiAgQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdmFyIGZvcm1hdFNldCwgZm9ybWF0V2l0aEFscGhhLCBmb3JtYXR0ZWRTdHJpbmcsIGhhc0FscGhhQW5kRm9ybWF0Tm90U2V0O1xuICAgIGZvcm1hdFNldCA9ICEhZm9ybWF0O1xuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLmZvcm1hdDtcbiAgICBmb3JtYXR0ZWRTdHJpbmcgPSBmYWxzZTtcbiAgICBoYXNBbHBoYUFuZEZvcm1hdE5vdFNldCA9ICFmb3JtYXRTZXQgJiYgdGhpcy5hIDwgMSAmJiB0aGlzLmEgPiAwO1xuICAgIGZvcm1hdFdpdGhBbHBoYSA9IGhhc0FscGhhQW5kRm9ybWF0Tm90U2V0ICYmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIiB8fCBmb3JtYXQgPT09IFwiaGV4M1wiIHx8IGZvcm1hdCA9PT0gXCJuYW1lXCIpO1xuICAgIGlmIChmb3JtYXQgPT09IFwicmdiXCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9SZ2JTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gXCJwcmdiXCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9QZXJjZW50YWdlUmdiU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIikge1xuICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSBcImhleDNcIikge1xuICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZyh0cnVlKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gXCJuYW1lXCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9OYW1lKCk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IFwiaHNsXCIpIHtcbiAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic2xTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gXCJoc3ZcIikge1xuICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzdlN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0V2l0aEFscGhhKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1JnYlN0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVkU3RyaW5nIHx8IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgKi9cblxuXG4gIENvbG9yLnByb3RvdHlwZS5yZWFkYWJsZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLnJlYWRhYmxlKHRoaXMsIGNvbG9yKTtcbiAgfTtcblxuICBDb2xvci5wcm90b3R5cGUudGV0cmFkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIENvbG9yLnRldHJhZCh0aGlzKTtcbiAgfTtcblxuICBDb2xvci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZXF1YWxzKHRoaXMsIGNvbG9yKTtcbiAgfTtcblxuICBDb2xvci5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIHZhciBjb2xvciwgcmdiO1xuICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgYW1vdW50ID0gMTA7XG4gICAgfVxuICAgIGNvbG9yID0gQ29sb3IuZGVzYXR1cmF0ZSh0aGlzLCBhbW91bnQpO1xuICAgIHJnYiA9IGNvbG9yLnRvUmdiKCk7XG4gICAgdGhpcy5yID0gcmdiLnI7XG4gICAgdGhpcy5nID0gcmdiLmc7XG4gICAgdGhpcy5iID0gcmdiLmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ29sb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnRvU3RyaW5nKCkpO1xuICB9O1xuXG4gIENvbG9yLnByb3RvdHlwZS5kYXJrZW4gPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICB2YXIgY29sb3IsIHJnYjtcbiAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgIGFtb3VudCA9IDEwO1xuICAgIH1cbiAgICBjb2xvciA9IENvbG9yLmRhcmtlbih0aGlzLCBhbW91bnQpO1xuICAgIHJnYiA9IGNvbG9yLnRvUmdiKCk7XG4gICAgdGhpcy5yID0gcmdiLnI7XG4gICAgdGhpcy5nID0gcmdiLmc7XG4gICAgdGhpcy5iID0gcmdiLmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ29sb3IucHJvdG90eXBlLmxpZ2h0ZW4gPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICB2YXIgY29sb3IsIHJnYjtcbiAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgIGFtb3VudCA9IDEwO1xuICAgIH1cbiAgICBjb2xvciA9IENvbG9yLmxpZ2h0ZW4odGhpcywgYW1vdW50KTtcbiAgICByZ2IgPSBjb2xvci50b1JnYigpO1xuICAgIHRoaXMuciA9IHJnYi5yO1xuICAgIHRoaXMuZyA9IHJnYi5nO1xuICAgIHRoaXMuYiA9IHJnYi5iO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qXG4gIElmIGlucHV0IGlzIGFuIG9iamVjdCwgZm9yY2UgMSBpbnRvIFwiMS4wXCIgdG8gaGFuZGxlIHJhdGlvcyBwcm9wZXJseVxuICBTdHJpbmcgaW5wdXQgcmVxdWlyZXMgXCIxLjBcIiBhcyBpbnB1dCwgc28gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgMVxuICBcbiAgR2l2ZW4gYSBzdHJpbmcgb3Igb2JqZWN0LCBjb252ZXJ0IHRoYXQgaW5wdXQgdG8gUkdCXG4gIFBvc3NpYmxlIHN0cmluZyBpbnB1dHM6XG4gIFxuICBcInJlZFwiXG4gIFwiI2YwMFwiIG9yIFwiZjAwXCJcbiAgXCIjZmYwMDAwXCIgb3IgXCJmZjAwMDBcIlxuICBcInJnYiAyNTUgMCAwXCIgb3IgXCJyZ2IgKDI1NSwgMCwgMClcIlxuICBcInJnYiAxLjAgMCAwXCIgb3IgXCJyZ2IgKDEsIDAsIDApXCJcbiAgXCJyZ2JhICgyNTUsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDI1NSwgMCwgMCwgMVwiXG4gIFwicmdiYSAoMS4wLCAwLCAwLCAxKVwiIG9yIFwicmdiYSAxLjAsIDAsIDAsIDFcIlxuICBcImhzbCgwLCAxMDAlLCA1MCUpXCIgb3IgXCJoc2wgMCAxMDAlIDUwJVwiXG4gIFwiaHNsYSgwLCAxMDAlLCA1MCUsIDEpXCIgb3IgXCJoc2xhIDAgMTAwJSA1MCUsIDFcIlxuICBcImhzdigwLCAxMDAlLCAxMDAlKVwiIG9yIFwiaHN2IDAgMTAwJSAxMDAlXCJcbiAgXG4gIEBwYXJhbSB7U3RyaW5nIHwgQ29sb3J9IGNvbG9yXG4gICovXG5cblxuICBDb2xvci5pbnB1dFRvUkdCID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB2YXIgYSwgZm9ybWF0LCBvaywgcmdiO1xuICAgIHJnYiA9IHtcbiAgICAgIHI6IDAsXG4gICAgICBnOiAwLFxuICAgICAgYjogMFxuICAgIH07XG4gICAgYSA9IDE7XG4gICAgb2sgPSBmYWxzZTtcbiAgICBmb3JtYXQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb2xvciA9IHN0cmluZ0lucHV0VG9PYmplY3QoY29sb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJyXCIpICYmIGNvbG9yLmhhc093blByb3BlcnR5KFwiZ1wiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcImJcIikpIHtcbiAgICAgICAgcmdiID0gQ29sb3IucmdiVG9SZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgZm9ybWF0ID0gKFN0cmluZyhjb2xvci5yKS5zdWJzdHIoLTEpID09PSBcIiVcIiA/IFwicHJnYlwiIDogXCJyZ2JcIik7XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiaFwiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcInNcIikgJiYgY29sb3IuaGFzT3duUHJvcGVydHkoXCJ2XCIpKSB7XG4gICAgICAgIGNvbG9yLnMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICBjb2xvci52ID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci52KTtcbiAgICAgICAgcmdiID0gQ29sb3IuaHN2VG9SZ2IoY29sb3IuaCwgY29sb3IucywgY29sb3Iudik7XG4gICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgZm9ybWF0ID0gXCJoc3ZcIjtcbiAgICAgIH0gZWxzZSBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJoXCIpICYmIGNvbG9yLmhhc093blByb3BlcnR5KFwic1wiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcImxcIikpIHtcbiAgICAgICAgY29sb3IucyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgIGNvbG9yLmwgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLmwpO1xuICAgICAgICByZ2IgPSBDb2xvci5oc2xUb1JnYihjb2xvci5oLCBjb2xvci5zLCBjb2xvci5sKTtcbiAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICBmb3JtYXQgPSBcImhzbFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiYVwiKSkge1xuICAgICAgICBhID0gY29sb3IuYTtcbiAgICAgIH1cbiAgICB9XG4gICAgYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9rOiBvayxcbiAgICAgIGZvcm1hdDogY29sb3IuZm9ybWF0IHx8IGZvcm1hdCxcbiAgICAgIHI6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgocmdiLnIsIDApKSxcbiAgICAgIGc6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgocmdiLmcsIDApKSxcbiAgICAgIGI6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgocmdiLmIsIDApKSxcbiAgICAgIGE6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8qXG4gIEhhbmRsZSBib3VuZHMgLyBwZXJjZW50YWdlIGNoZWNraW5nIHRvIGNvbmZvcm0gdG8gQ1NTIGNvbG9yIHNwZWNcbiAgPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvPlxuICBcbiAgQG1ldGhvZCByZ2JUb1JnYlxuICBcbiAgQHBhcmFtIHtJbnRlZ2VyfSByIGluIDAuLjI1NSBvciAwLi4xXG4gIEBwYXJhbSB7SW50ZWdlcn0gZyBpbiAwLi4yNTUgb3IgMC4uMVxuICBAcGFyYW0ge0ludGVnZXJ9IGIgaW4gMC4uMjU1IG9yIDAuLjFcbiAgXG4gIEByZXR1cm4ge09iamVjdH0geyByLCBnLCBiIH0gaW4gMC4uMjU1XG4gICovXG5cblxuICBDb2xvci5yZ2JUb1JnYiA9IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogYm91bmQwMShyLCAyNTUpICogMjU1LFxuICAgICAgZzogYm91bmQwMShnLCAyNTUpICogMjU1LFxuICAgICAgYjogYm91bmQwMShiLCAyNTUpICogMjU1XG4gICAgfTtcbiAgfTtcblxuICAvKlxuICBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLlxuICBcbiAgQG1ldGhvZCByZ2JUb0hzbFxuICBcbiAgQHBhcmFtIHtJbnRlZ2VyfSByIGluIDAuLjI1NSBvciAwLi4xXG4gIEBwYXJhbSB7SW50ZWdlcn0gZyBpbiAwLi4yNTUgb3IgMC4uMVxuICBAcGFyYW0ge0ludGVnZXJ9IGIgaW4gMC4uMjU1IG9yIDAuLjFcbiAgXG4gIEByZXR1cm4ge09iamVjdH0geyBoLCBzLCBsIH0gaW4gMC4uMVxuICAqL1xuXG5cbiAgQ29sb3IucmdiVG9Ic2wgPSBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgdmFyIGQsIGgsIGwsIG1heCwgbWluLCBzO1xuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGggPSB2b2lkIDA7XG4gICAgcyA9IHZvaWQgMDtcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgaCA9IHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gbWF4IC0gbWluO1xuICAgICAgcyA9IChsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKSk7XG4gICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBiOlxuICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBoOiBoLFxuICAgICAgczogcyxcbiAgICAgIGw6IGxcbiAgICB9O1xuICB9O1xuXG4gIC8qXG4gIENvbnZlcnRzIGFuIEhTTCBjb2xvciB2YWx1ZSB0byBSR0IuXG4gIFxuICBAbWV0aG9kIGhzbFRvUmdiXG4gIEBwYXJhbSB7SW50ZWdlcn0gaCBpbiAwLi4zNjAgb3IgMC4uMVxuICBAcGFyYW0ge0ludGVnZXJ9IHMgaW4gMC4uMTAwIG9yIDAuLjFcbiAgQHBhcmFtIHtJbnRlZ2VyfSBsIGluIDAuLjEwMCBvciAwLi4xXG4gIEByZXR1cm4ge09iamVjdH0geyByLCBnLCBiIH0gaW4gMC4uMjU1XG4gICovXG5cblxuICBDb2xvci5oc2xUb1JnYiA9IGZ1bmN0aW9uKGgsIHMsIGwpIHtcbiAgICB2YXIgYiwgZywgaHVlMnJnYiwgcCwgcSwgcjtcbiAgICBodWUycmdiID0gZnVuY3Rpb24ocCwgcSwgdCkge1xuICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgIHQgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICB0IC09IDE7XG4gICAgICB9XG4gICAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH1cbiAgICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbiAgICByID0gdm9pZCAwO1xuICAgIGcgPSB2b2lkIDA7XG4gICAgYiA9IHZvaWQgMDtcbiAgICBoID0gYm91bmQwMShoLCAzNjApO1xuICAgIHMgPSBib3VuZDAxKHMsIDEwMCk7XG4gICAgbCA9IGJvdW5kMDEobCwgMTAwKTtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcSA9IChsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzKTtcbiAgICAgIHAgPSAyICogbCAtIHE7XG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcjogciAqIDI1NSxcbiAgICAgIGc6IGcgKiAyNTUsXG4gICAgICBiOiBiICogMjU1XG4gICAgfTtcbiAgfTtcblxuICAvKlxuICBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWXG4gIFxuICBAbWV0aG9kIHJnYlRvSHN2XG4gIEBwYXJhbSB7SW50ZWdlcn0gciBpbiAwLi4yNTUgb3IgMC4uMVxuICBAcGFyYW0ge0ludGVnZXJ9IGcgaW4gMC4uMjU1IG9yIDAuLjFcbiAgQHBhcmFtIHtJbnRlZ2VyfSBiIGluIDAuLjI1NSBvciAwLi4xXG4gIEByZXR1cm4ge09iamVjdH0geyBoLCBzLCB2IH0gaW4gMC4uMVxuICAqL1xuXG5cbiAgQ29sb3IucmdiVG9Ic3YgPSBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgdmFyIGQsIGgsIG1heCwgbWluLCBzLCB2O1xuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGggPSB2b2lkIDA7XG4gICAgcyA9IHZvaWQgMDtcbiAgICB2ID0gbWF4O1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IChtYXggPT09IDAgPyAwIDogZCAvIG1heCk7XG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgY2FzZSByOlxuICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBnOlxuICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYjpcbiAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaDogaCxcbiAgICAgIHM6IHMsXG4gICAgICB2OiB2XG4gICAgfTtcbiAgfTtcblxuICAvKlxuICBDb252ZXJ0cyBhbiBIU1YgY29sb3IgdmFsdWUgdG8gUkdCLlxuICBcbiAgQG1ldGhvZCBoc3ZUb1JnYlxuICBAcGFyYW0ge0ludGVnZXJ9IGggaW4gMC4uMzYwIG9yIDAuLjFcbiAgQHBhcmFtIHtJbnRlZ2VyfSBzIGluIDAuLjEwMCBvciAwLi4xXG4gIEBwYXJhbSB7SW50ZWdlcn0gdiBpbiAwLi4xMDAgb3IgMC4uMVxuICBAcmV0dXJuIHtPYmplY3R9IHsgciwgZywgYiB9IGluIDAuLjI1NVxuICAqL1xuXG5cbiAgQ29sb3IuaHN2VG9SZ2IgPSBmdW5jdGlvbihoLCBzLCB2KSB7XG4gICAgdmFyIGIsIGYsIGcsIGksIG1vZCwgcCwgcSwgciwgdDtcbiAgICBoID0gYm91bmQwMShoLCAzNjApICogNjtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIHYgPSBib3VuZDAxKHYsIDEwMCk7XG4gICAgaSA9IE1hdGguZmxvb3IoaCk7XG4gICAgZiA9IGggLSBpO1xuICAgIHAgPSB2ICogKDEgLSBzKTtcbiAgICBxID0gdiAqICgxIC0gZiAqIHMpO1xuICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG4gICAgbW9kID0gaSAlIDY7XG4gICAgciA9IFt2LCBxLCBwLCBwLCB0LCB2XVttb2RdO1xuICAgIGcgPSBbdCwgdiwgdiwgcSwgcCwgcF1bbW9kXTtcbiAgICBiID0gW3AsIHAsIHQsIHYsIHYsIHFdW21vZF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHIgKiAyNTUsXG4gICAgICBnOiBnICogMjU1LFxuICAgICAgYjogYiAqIDI1NVxuICAgIH07XG4gIH07XG5cbiAgLypcbiAgQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIGhleFxuICBcbiAgQG1ldGhvZCByZ2JUb0hleFxuICBAcGFyYW0ge0ludGVnZXJ9IHIgaW4gMC4uMjU1XG4gIEBwYXJhbSB7SW50ZWdlcn0gZyBpbiAwLi4yNTVcbiAgQHBhcmFtIHtJbnRlZ2VyfSBiIGluIDAuLjI1NVxuICBAcGFyYW0ge0Jvb2xlYW59IGFsbG93M0NoYXJcbiAgQHJldHVybiB7U3RyaW5nfSAzIG9yIDYgY2hhcmFjdGVyIGhleFxuICAqL1xuXG5cbiAgQ29sb3IucmdiVG9IZXggPSBmdW5jdGlvbihyLCBnLCBiLCBhbGxvdzNDaGFyKSB7XG4gICAgdmFyIGhleDtcbiAgICBpZiAoYWxsb3czQ2hhciA9PSBudWxsKSB7XG4gICAgICBhbGxvdzNDaGFyID0gZmFsc2U7XG4gICAgfVxuICAgIGhleCA9IFtwYWQyKE1hdGgucm91bmQocikudG9TdHJpbmcoMTYpKSwgcGFkMihNYXRoLnJvdW5kKGcpLnRvU3RyaW5nKDE2KSksIHBhZDIoTWF0aC5yb3VuZChiKS50b1N0cmluZygxNikpXTtcbiAgICBpZiAoYWxsb3czQ2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09PSBoZXhbMF0uY2hhckF0KDEpICYmIGhleFsxXS5jaGFyQXQoMCkgPT09IGhleFsxXS5jaGFyQXQoMSkgJiYgaGV4WzJdLmNoYXJBdCgwKSA9PT0gaGV4WzJdLmNoYXJBdCgxKSkge1xuICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xuICB9O1xuXG4gIHJldHVybiBDb2xvcjtcblxufSkoKTtcblxuLypcblBlcm1pc3NpdmUgc3RyaW5nIHBhcnNpbmcuIFRha2UgaW4gYSBudW1iZXIgb2YgZm9ybWF0cywgYW5kIG91dHB1dCBhbiBvYmplY3RcbmJhc2VkIG9uIGRldGVjdGVkIGZvcm1hdC5cbkBtZXRob2Qgc3RyaW5nSW5wdXRUb09iamVjdFxuQHBhcmFtIHtTdHJpbmcgfCBDb2xvcn0gY29sb3JcbkByZXR1cm4ge09iamVjdH0gYHsgciwgZywgYiB9YCBvciBgeyBoLCBzLCBsIH1gIG9yIGB7IGgsIHMsIHZ9YFxuKi9cblxuXG5zdHJpbmdJbnB1dFRvT2JqZWN0ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgdmFyIG1hdGNoLCBuYW1lZDtcbiAgY29sb3IgPSBjb2xvci5yZXBsYWNlKHRyaW1MZWZ0LCBcIlwiKS5yZXBsYWNlKHRyaW1SaWdodCwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgbmFtZWQgPSBmYWxzZTtcbiAgaWYgKENPTE9SX05BTUVTW2NvbG9yXSkge1xuICAgIGNvbG9yID0gQ09MT1JfTkFNRVNbY29sb3JdO1xuICAgIG5hbWVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjb2xvciA9PT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgKHtcbiAgICAgIHI6IDAsXG4gICAgICBnOiAwLFxuICAgICAgYjogMCxcbiAgICAgIGE6IDAsXG4gICAgICBmb3JtYXQ6IFwibmFtZVwiXG4gICAgfSk7XG4gIH1cbiAgbWF0Y2ggPSB2b2lkIDA7XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiB7XG4gICAgICByOiBtYXRjaFsxXSxcbiAgICAgIGc6IG1hdGNoWzJdLFxuICAgICAgYjogbWF0Y2hbM11cbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogbWF0Y2hbMV0sXG4gICAgICBnOiBtYXRjaFsyXSxcbiAgICAgIGI6IG1hdGNoWzNdLFxuICAgICAgYTogbWF0Y2hbNF1cbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiB7XG4gICAgICBoOiBtYXRjaFsxXSxcbiAgICAgIHM6IG1hdGNoWzJdLFxuICAgICAgbDogbWF0Y2hbM11cbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDogbWF0Y2hbMV0sXG4gICAgICBzOiBtYXRjaFsyXSxcbiAgICAgIGw6IG1hdGNoWzNdLFxuICAgICAgYTogbWF0Y2hbNF1cbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiB7XG4gICAgICBoOiBtYXRjaFsxXSxcbiAgICAgIHM6IG1hdGNoWzJdLFxuICAgICAgdjogbWF0Y2hbM11cbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VIZXgobWF0Y2hbMV0pLFxuICAgICAgZzogcGFyc2VIZXgobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VIZXgobWF0Y2hbM10pLFxuICAgICAgZm9ybWF0OiAobmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCIpXG4gICAgfTtcbiAgfVxuICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSGV4KG1hdGNoWzFdICsgXCJcIiArIG1hdGNoWzFdKSxcbiAgICAgIGc6IHBhcnNlSGV4KG1hdGNoWzJdICsgXCJcIiArIG1hdGNoWzJdKSxcbiAgICAgIGI6IHBhcnNlSGV4KG1hdGNoWzNdICsgXCJcIiArIG1hdGNoWzNdKSxcbiAgICAgIGZvcm1hdDogKG5hbWVkID8gXCJuYW1lXCIgOiBcImhleFwiKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuQ29sb3IuZnJvbVJhdGlvID0gZnVuY3Rpb24oY29sb3IsIG9wdHMpIHtcbiAgdmFyIGksIG5ld0NvbG9yO1xuICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2YgY29sb3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICBuZXdDb2xvciA9IHt9O1xuICAgIGZvciAoaSBpbiBjb2xvcikge1xuICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmIChpID09PSBcImFcIikge1xuICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29sb3JbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb2xvciA9IG5ld0NvbG9yO1xuICB9XG4gIHJldHVybiBuZXcgQ29sb3IoY29sb3IsIG9wdHMpO1xufTtcblxuQ29sb3IuZXF1YWxzID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcbiAgaWYgKCFjb2xvcjEgfHwgIWNvbG9yMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKG5ldyBDb2xvcihjb2xvcjEpKS50b1JnYlN0cmluZygpID09PSAobmV3IENvbG9yKGNvbG9yMikpLnRvUmdiU3RyaW5nKCk7XG59O1xuXG5Db2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIENvbG9yLmZyb21SYXRpbyh7XG4gICAgcjogTWF0aC5yYW5kb20oKSxcbiAgICBnOiBNYXRoLnJhbmRvbSgpLFxuICAgIGI6IE1hdGgucmFuZG9tKClcbiAgfSk7XG59O1xuXG5Db2xvci5kZXNhdHVyYXRlID0gZnVuY3Rpb24oY29sb3IsIGFtb3VudCkge1xuICB2YXIgaHNsO1xuICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICBhbW91bnQgPSAxMDtcbiAgfVxuICBoc2wgPSAobmV3IENvbG9yKGNvbG9yKSkudG9Ic2woKTtcbiAgaHNsLnMgLT0gYW1vdW50IC8gMTAwO1xuICBoc2wucyA9IE1hdGhlbWF0aWMuY2xhbXAwMShoc2wucyk7XG4gIHJldHVybiBuZXcgQ29sb3IoaHNsKTtcbn07XG5cbkNvbG9yLnNhdHVyYXRlID0gZnVuY3Rpb24oY29sb3IsIGFtb3VudCkge1xuICB2YXIgaHNsO1xuICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICBhbW91bnQgPSAxMDtcbiAgfVxuICBoc2wgPSAobmV3IENvbG9yKGNvbG9yKSkudG9Ic2woKTtcbiAgaHNsLnMgKz0gYW1vdW50IC8gMTAwO1xuICBoc2wucyA9IE1hdGhlbWF0aWMuY2xhbXAwMShoc2wucyk7XG4gIHJldHVybiBuZXcgQ29sb3IoaHNsKTtcbn07XG5cbkNvbG9yLmdyZXlzY2FsZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gIHJldHVybiBDb2xvci5kZXNhdHVyYXRlKGNvbG9yLCAxMDApO1xufTtcblxuQ29sb3IubGlnaHRlbiA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgdmFyIGhzbDtcbiAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgYW1vdW50ID0gMTA7XG4gIH1cbiAgaHNsID0gKG5ldyBDb2xvcihjb2xvcikpLnRvSHNsKCk7XG4gIGhzbC5sICs9IGFtb3VudCAvIDEwMDtcbiAgaHNsLmwgPSBNYXRoZW1hdGljLmNsYW1wMDEoaHNsLmwpO1xuICByZXR1cm4gbmV3IENvbG9yKGhzbCk7XG59O1xuXG5Db2xvci5kYXJrZW4gPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gIHZhciBoc2w7XG4gIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgIGFtb3VudCA9IDEwO1xuICB9XG4gIGhzbCA9IChuZXcgQ29sb3IoY29sb3IpKS50b0hzbCgpO1xuICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gIGhzbC5sID0gTWF0aGVtYXRpYy5jbGFtcDAxKGhzbC5sKTtcbiAgcmV0dXJuIG5ldyBDb2xvcihoc2wpO1xufTtcblxuQ29sb3IuY29tcGxlbWVudCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gIHZhciBoc2w7XG4gIGhzbCA9IChuZXcgQ29sb3IoY29sb3IpKS50b0hzbCgpO1xuICBoc2wuaCA9IChoc2wuaCArIDE4MCkgJSAzNjA7XG4gIHJldHVybiBuZXcgQ29sb3IoaHNsKTtcbn07XG5cbkNvbG9yLnRyaWFkID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgdmFyIGgsIGhzbDtcbiAgaHNsID0gKG5ldyBDb2xvcihjb2xvcikpLnRvSHNsKCk7XG4gIGggPSBoc2wuaDtcbiAgcmV0dXJuIFtcbiAgICBuZXcgQ29sb3IoY29sb3IpLCBuZXcgQ29sb3Ioe1xuICAgICAgaDogKGggKyAxMjApICUgMzYwLFxuICAgICAgczogaHNsLnMsXG4gICAgICBsOiBoc2wubFxuICAgIH0pLCBuZXcgQ29sb3Ioe1xuICAgICAgaDogKGggKyAyNDApICUgMzYwLFxuICAgICAgczogaHNsLnMsXG4gICAgICBsOiBoc2wubFxuICAgIH0pXG4gIF07XG59O1xuXG5Db2xvci50ZXRyYWQgPSBmdW5jdGlvbihjb2xvcikge1xuICB2YXIgaCwgaHNsO1xuICBoc2wgPSAobmV3IENvbG9yKGNvbG9yKSkudG9Ic2woKTtcbiAgaCA9IGhzbC5oO1xuICByZXR1cm4gW1xuICAgIG5ldyBDb2xvcihjb2xvciksIG5ldyBDb2xvcih7XG4gICAgICBoOiAoaCArIDkwKSAlIDM2MCxcbiAgICAgIHM6IGhzbC5zLFxuICAgICAgbDogaHNsLmxcbiAgICB9KSwgbmV3IENvbG9yKHtcbiAgICAgIGg6IChoICsgMTgwKSAlIDM2MCxcbiAgICAgIHM6IGhzbC5zLFxuICAgICAgbDogaHNsLmxcbiAgICB9KSwgbmV3IENvbG9yKHtcbiAgICAgIGg6IChoICsgMjcwKSAlIDM2MCxcbiAgICAgIHM6IGhzbC5zLFxuICAgICAgbDogaHNsLmxcbiAgICB9KVxuICBdO1xufTtcblxuQ29sb3Iuc3BsaXRjb21wbGVtZW50ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgdmFyIGgsIGhzbDtcbiAgaHNsID0gKG5ldyBDb2xvcihjb2xvcikpLnRvSHNsKCk7XG4gIGggPSBoc2wuaDtcbiAgcmV0dXJuIFtcbiAgICBuZXcgQ29sb3IoY29sb3IpLCBuZXcgQ29sb3Ioe1xuICAgICAgaDogKGggKyA3MikgJSAzNjAsXG4gICAgICBzOiBoc2wucyxcbiAgICAgIGw6IGhzbC5sXG4gICAgfSksIG5ldyBDb2xvcih7XG4gICAgICBoOiAoaCArIDIxNikgJSAzNjAsXG4gICAgICBzOiBoc2wucyxcbiAgICAgIGw6IGhzbC5sXG4gICAgfSlcbiAgXTtcbn07XG5cbkNvbG9yLmFuYWxvZ291cyA9IGZ1bmN0aW9uKGNvbG9yLCByZXN1bHRzLCBzbGljZXMpIHtcbiAgdmFyIGhzbCwgcGFydCwgcmV0O1xuICBpZiAocmVzdWx0cyA9PSBudWxsKSB7XG4gICAgcmVzdWx0cyA9IDY7XG4gIH1cbiAgaWYgKHNsaWNlcyA9PSBudWxsKSB7XG4gICAgc2xpY2VzID0gMzA7XG4gIH1cbiAgaHNsID0gKG5ldyBDb2xvcihjb2xvcikpLnRvSHNsKCk7XG4gIHBhcnQgPSAzNjAgLyBzbGljZXM7XG4gIHJldCA9IFtuZXcgQ29sb3IoY29sb3IpXTtcbiAgaHNsLmggPSAoKGhzbC5oIC0gKHBhcnQgKiByZXN1bHRzID4+IDEpKSArIDcyMCkgJSAzNjA7XG4gIHdoaWxlICgtLXJlc3VsdHMpIHtcbiAgICBoc2wuaCA9IChoc2wuaCArIHBhcnQpICUgMzYwO1xuICAgIHJldC5wdXNoKG5ldyBDb2xvcihoc2wpKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuQ29sb3IubW9ub2Nocm9tYXRpYyA9IGZ1bmN0aW9uKGNvbG9yLCByZXN1bHRzKSB7XG4gIHZhciBoLCBoc3YsIG1vZGlmaWNhdGlvbiwgcmV0LCBzLCB2O1xuICBpZiAocmVzdWx0cyA9PSBudWxsKSB7XG4gICAgcmVzdWx0cyA9IDY7XG4gIH1cbiAgaHN2ID0gKG5ldyBDb2xvcihjb2xvcikpLnRvSHN2KCk7XG4gIGggPSBoc3YuaDtcbiAgcyA9IGhzdi5zO1xuICB2ID0gaHN2LnY7XG4gIHJldCA9IFtdO1xuICBtb2RpZmljYXRpb24gPSAxIC8gcmVzdWx0cztcbiAgd2hpbGUgKHJlc3VsdHMtLSkge1xuICAgIHJldC5wdXNoKENvbG9yKHtcbiAgICAgIGg6IGgsXG4gICAgICBzOiBzLFxuICAgICAgdjogdlxuICAgIH0pKTtcbiAgICB2ID0gKHYgKyBtb2RpZmljYXRpb24pICUgMTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuQ29sb3IucmVhZGFiaWxpdHkgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuICB2YXIgYSwgYiwgYnJpZ2h0bmVzc0EsIGJyaWdodG5lc3NCLCBjb2xvckRpZmY7XG4gIGEgPSAobmV3IENvbG9yKGNvbG9yMSkpLnRvUmdiKCk7XG4gIGIgPSAobmV3IENvbG9yKGNvbG9yMikpLnRvUmdiKCk7XG4gIGJyaWdodG5lc3NBID0gKGEuciAqIDI5OSArIGEuZyAqIDU4NyArIGEuYiAqIDExNCkgLyAxMDAwO1xuICBicmlnaHRuZXNzQiA9IChiLnIgKiAyOTkgKyBiLmcgKiA1ODcgKyBiLmIgKiAxMTQpIC8gMTAwMDtcbiAgY29sb3JEaWZmID0gTWF0aC5tYXgoYS5yLCBiLnIpIC0gTWF0aC5taW4oYS5yLCBiLnIpICsgTWF0aC5tYXgoYS5nLCBiLmcpIC0gTWF0aC5taW4oYS5nLCBiLmcpICsgTWF0aC5tYXgoYS5iLCBiLmIpIC0gTWF0aC5taW4oYS5iLCBiLmIpO1xuICByZXR1cm4ge1xuICAgIGJyaWdodG5lc3M6IE1hdGguYWJzKGJyaWdodG5lc3NBIC0gYnJpZ2h0bmVzc0IpLFxuICAgIGNvbG9yOiBjb2xvckRpZmZcbiAgfTtcbn07XG5cbkNvbG9yLnJlYWRhYmxlID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcbiAgdmFyIHJlYWRhYmlsaXR5O1xuICByZWFkYWJpbGl0eSA9IENvbG9yLnJlYWRhYmlsaXR5KGNvbG9yMSwgY29sb3IyKTtcbiAgcmV0dXJuIHJlYWRhYmlsaXR5LmJyaWdodG5lc3MgPiAxMjUgJiYgcmVhZGFiaWxpdHkuY29sb3IgPiA1MDA7XG59O1xuXG5Db2xvci5tb3N0UmVhZGFibGUgPSBmdW5jdGlvbihiYXNlQ29sb3IsIGNvbG9yTGlzdCkge1xuICB2YXIgYmVzdENvbG9yLCBiZXN0SXNSZWFkYWJsZSwgYmVzdFNjb3JlLCBpLCByZWFkYWJpbGl0eSwgcmVhZGFibGUsIHNjb3JlO1xuICBiZXN0Q29sb3IgPSBudWxsO1xuICBiZXN0U2NvcmUgPSAwO1xuICBiZXN0SXNSZWFkYWJsZSA9IGZhbHNlO1xuICBpID0gMDtcbiAgd2hpbGUgKGkgPCBjb2xvckxpc3QubGVuZ3RoKSB7XG4gICAgcmVhZGFiaWxpdHkgPSBDb2xvci5yZWFkYWJpbGl0eShiYXNlQ29sb3IsIGNvbG9yTGlzdFtpXSk7XG4gICAgcmVhZGFibGUgPSByZWFkYWJpbGl0eS5icmlnaHRuZXNzID4gMTI1ICYmIHJlYWRhYmlsaXR5LmNvbG9yID4gNTAwO1xuICAgIHNjb3JlID0gMyAqIChyZWFkYWJpbGl0eS5icmlnaHRuZXNzIC8gMTI1KSArIChyZWFkYWJpbGl0eS5jb2xvciAvIDUwMCk7XG4gICAgaWYgKChyZWFkYWJsZSAmJiAhYmVzdElzUmVhZGFibGUpIHx8IChyZWFkYWJsZSAmJiBiZXN0SXNSZWFkYWJsZSAmJiBzY29yZSA+IGJlc3RTY29yZSkgfHwgKCghcmVhZGFibGUpICYmICghYmVzdElzUmVhZGFibGUpICYmIHNjb3JlID4gYmVzdFNjb3JlKSkge1xuICAgICAgYmVzdElzUmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgYmVzdENvbG9yID0gbmV3IENvbG9yKGNvbG9yTGlzdFtpXSk7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4gYmVzdENvbG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDb2xvcjogcmVxdWlyZShcIi4vY29sb3JcIiksXG4gIEZvbnQ6IHJlcXVpcmUoXCIuL2ZvbnRcIilcbn07XG5cbi8qXG4vL0Agc291cmNlTWFwcGluZ1VSTD1leHBvcnRzLm1hcFxuKi9cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjNcbi8qXG5JbnNwaXJlZCBieSBGb250LmpzIGJ5ICBNaWtlIFwiUG9tYXhcIiBLYW1lcm1hbnNcbkBzZWUgaHR0cDovL2dpdGh1Yi5jb20vUG9tYXgvRm9udC5qc1xuKi9cblxudmFyIEZPTlRfQ0FDSEUsIEZPTlRfREVGQVVMVFMsIEZvbnQsIE1hdGhtZXRpY3MsIFRyaWdnZXJhYmxlLCBjaHIsIGNocjE2LCBkZWNoZXgsIGZ3b3JkLCB1bG9uZywgdXNob3J0LFxuICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbk1hdGhtZXRpY3MgPSByZXF1aXJlKFwiLi4vbWF0aC9tYXRoXCIpO1xuXG5UcmlnZ2VyYWJsZSA9IHJlcXVpcmUoXCIuLi9jb3JlL3RyaWdnZXJhYmxlXCIpO1xuXG5GT05UX0NBQ0hFID0ge307XG5cbkZPTlRfREVGQVVMVFMgPSB7XG4gIGZvbnRGYW1pbHk6ICdWZXJkZW5hJyxcbiAgZm9udFNpemU6IDEyXG59O1xuXG5jaHIgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsKTtcbn07XG5cbmNocjE2ID0gZnVuY3Rpb24odmFsKSB7XG4gIHZhciBiMSwgYjI7XG4gIGlmICh2YWwgPCAyNTYpIHtcbiAgICByZXR1cm4gY2hyKDApICsgY2hyKHZhbCk7XG4gIH1cbiAgYjEgPSB2YWwgPj4gODtcbiAgYjIgPSB2YWwgJiAweEZGO1xuICByZXR1cm4gY2hyKGIxKSArIGNocihiMik7XG59O1xuXG5kZWNoZXggPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHZhbCA8IDApIHtcbiAgICB2YWwgPSAweEZGRkZGRkZGICsgdmFsICsgMTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCkudG9TdHJpbmcoMTYpO1xufTtcblxudXNob3J0ID0gZnVuY3Rpb24oYjEsIGIyKSB7XG4gIHJldHVybiAyNTYgKiBiMSArIGIyO1xufTtcblxuZndvcmQgPSBmdW5jdGlvbihiMSwgYjIpIHtcbiAgdmFyIG5lZ2F0aXZlLCB2YWw7XG4gIG5lZ2F0aXZlID0gYjEgPj4gNyA9PT0gMTtcbiAgdmFsID0gdm9pZCAwO1xuICBiMSA9IGIxICYgMHg3RjtcbiAgdmFsID0gMjU2ICogYjEgKyBiMjtcbiAgaWYgKCFuZWdhdGl2ZSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIHZhbCAtIDB4ODAwMDtcbn07XG5cbnVsb25nID0gZnVuY3Rpb24oYjEsIGIyLCBiMywgYjQpIHtcbiAgcmV0dXJuIDE2Nzc3MjE2ICogYjEgKyA2NTUzNiAqIGIyICsgMjU2ICogYjMgKyBiNDtcbn07XG5cbi8qXG5Gb250IG1hbmlwdWxhdGlvbnMgYW5kIG1lYXN1cmVtZW50XG5cbkBub3RlIEdhbWVDb3JlLmV4cG9ydHMuVXRpbHMuRm9udFxuKi9cblxuXG5Gb250ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRm9udCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGb250KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgb3B0aW9ucy5zcmMgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSB0aGlzLnVybCA/IG9wdGlvbnMuZm9udEZhbWlseSB8fCBcImZvbnRcIiArIE1hdGhtZXRpY3MucmFuZG9tSW50KDAsIDk5OTk5OSkgOiBGT05UX0RFRkFVTFRTLmZvbnRGYW1pbHk7XG4gICAgdGhpcy5mb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgb3B0aW9ucy5zaXplIHx8IEZPTlRfREVGQVVMVFMuZm9udFNpemU7XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBcIlwiO1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCBcIlwiO1xuICAgIHRoaXMuYmFzZTY0ID0gXCJBQUVBQUFBS0FJQUFBd0FnVDFNdk1nQUFBQUFBQUFDc0FBQUFXR050WVhBQVwiICsgXCJBQUFBQUFBQkJBQUFBQ3huYkhsbUFBQUFBQUFBQVRBQUFBQVFhR1ZoWkFBQUFcIiArIFwiQUFBQUFGQUFBQUFPR2hvWldFQUFBQUFBQUFCZUFBQUFDUm9iWFI0QUFBQUFBXCIgKyBcIkFBQVp3QUFBQUliRzlqWVFBQUFBQUFBQUdrQUFBQUNHMWhlSEFBQUFBQUFBQVwiICsgXCJCckFBQUFDQnVZVzFsQUFBQUFBQUFBY3dBQUFBZ2NHOXpkQUFBQUFBQUFBSHNcIiArIFwiQUFBQUVBQUVBQUVBWkFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBTUFBUUFcIiArIFwiQUFBd0FCQUFnQUFBQUJBQUVBQUVBQUFCQi8vOEFBQUJCLy8vL3dBQUJBQUFBXCIgKyBcIkFBQUJBQUFBQUFBQUFBQUFBQUFBTVFBQUFRQUFBQUFBQUFBQUFBQmZEenoxQVwiICsgXCJBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUVBQWdcIiArIFwiQUFBQUFBQUFBQkFBQUFBUUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFJQUFBQUFRQUFBQUlBQVFBQlwiICsgXCJBQUFBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFIZ0FEQUFFRUNcIiArIFwiUUFCQUFBQUFBQURBQUVFQ1FBQ0FBSUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUE9PVwiO1xuICAgIC8qXG4gICAgdGhlc2UgbWV0cmljcyByZXByZXNlbnQgdGhlIGZvbnQtaW5kaWNhdGVkIHZhbHVlcyxcbiAgICBub3QgdGhlIHZhbHVlcyBwZXJ0YWluaW5nIHRvIHRleHQgYXMgaXQgaXMgcmVuZGVyZWRcbiAgICBvbiB0aGUgcGFnZSAodXNlIGZvbnRtZXRyaWNzLmpzIGZvciB0aGlzIGluc3RlYWQpLlxuICAgICovXG5cbiAgICB0aGlzLm1ldHJpY3MgPSB7XG4gICAgICBxdWFkc2l6ZTogMCxcbiAgICAgIGxlYWRpbmc6IDAsXG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBkZXNjZW50OiAwLFxuICAgICAgd2VpZ2h0Y2xhc3M6IDQwMFxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3lzdGVtZm9udFwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fc3lzdGVtZm9udCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zeXN0ZW1mb250O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG9yZWFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N5c3RlbWZvbnQgPSBvcmVhbGx5O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXMgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBmYWxzZTtcbiAgICB0aGlzLnN0eWxlTm9kZSA9IGZhbHNlO1xuICAgIC8qXG4gICAgd2Ugd2FudCBGb250IHRvIGRvIHRoZSBzYW1lIHRoaW5nIEltYWdlIGRvZXMgd2hlblxuICAgIHdlIHNldCB0aGUgXCJzcmNcIiBwcm9wZXJ0eSB2YWx1ZSwgc28gd2UgdXNlIHRoZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmdW5jdGlvbiB0byBiaW5kIGEgc2V0dGVyXG4gICAgdGhhdCBkb2VzIG1vcmUgdGhhbiBqdXN0IGJpbmQgdmFsdWVzLlxuICAgICovXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzcmNcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkRm9udCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnVybCkge1xuICAgICAgdGhpcy5sb2FkRm9udCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgb25jZSB0aGUgZm9udCBpcyBkb25lXG4gIGxvYWRpbmcsIGl0cyBtZXRyaWNzIGhhdmUgYmVlbiBkZXRlcm1pbmVkLCBhbmQgaXRcbiAgaGFzIGJlZW4gcGFyc2VkIGZvciB1c2Ugb24tcGFnZS4gQnkgZGVmYXVsdCwgdGhpc1xuICBmdW5jdGlvbiBkb2VzIG5vdGhpbmcsIGFuZCB1c2VycyBjYW4gYmluZCB0aGVpclxuICBvd24gaGFuZGxlciBmdW5jdGlvbi5cbiAgKi9cblxuXG4gIEZvbnQucHJvdG90eXBlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge307XG5cbiAgLypcbiAgVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIGEgcHJvYmxlbVxuICBsb2FkaW5nIHRoZSBmb250LlxuICAqL1xuXG5cbiAgRm9udC5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKCkge307XG5cbiAgLypcbiAgdmFsaWRhdGlvbiBmdW5jdGlvbiB0byBzZWUgaWYgdGhlIHplcm8td2lkdGggc3R5bGVkXG4gIHRleHQgaXMgbm8gbG9uZ2VyIHplcm8td2lkdGguIElmIHRoaXMgaXMgdHJ1ZSwgdGhlXG4gIGZvbnQgaXMgcHJvcGVybHkgZG9uZSBsb2FkaW5nLiBJZiB0aGlzIGlzIGZhbHNlLCB0aGVcbiAgZnVuY3Rpb24gY2FsbHMgaXRzZWxmIHZpYSBhIHRpbWVvdXRcbiAgKi9cblxuXG4gIEZvbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24odGFyZ2V0LCB6ZXJvLCBtYXJrLCBmb250LCB0aW1lb3V0KSB7XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUsIHdpZHRoO1xuICAgIGlmICh0aW1lb3V0ICE9PSBmYWxzZSAmJiB0aW1lb3V0IDwgMCkge1xuICAgICAgdGhpcy5vbmVycm9yKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgc3lzdGVtIGZvbnQgJ1wiICsgdGhpcy5mb250RmFtaWx5ICsgXCInIGNvdWxkIG5vdCBiZSBsb2FkZWQgKGl0IG1heSBub3QgYmUgaW5zdGFsbGVkKS5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbXB1dGVkU3R5bGUgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgXCJcIik7XG4gICAgd2lkdGggPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ3aWR0aFwiKS5yZXBsYWNlKFwicHhcIiwgXCJcIik7XG4gICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZCh6ZXJvKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm9ubG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb250LnZhbGlkYXRlKHRhcmdldCwgemVybywgbWFyaywgZm9udCwgKHRpbWVvdXQgPT09IGZhbHNlID8gZmFsc2UgOiB0aW1lb3V0IC0gNTApKTtcbiAgICAgIH0pLCA1MCk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBkb25lIGRvd25sb2FkaW5nLlxuICAqL1xuXG5cbiAgRm9udC5wcm90b3R5cGUub25kb3dubG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNmZiwgZGF0YSwgZXJyb3IsIGluc3RhbmNlLCBpc0NGRiwgaXNUVEYsIGlzV09GRiwgcHJpbnRDaGFyLCB0dGYsIHZlcnNpb24sIHdvZmY7XG4gICAgaW5zdGFuY2UgPSB0aGlzO1xuICAgIGVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2Uub25lcnJvcihtc2cpO1xuICAgIH07XG4gICAgdHRmID0gY2hyKDApICsgY2hyKDEpICsgY2hyKDApICsgY2hyKDApO1xuICAgIGNmZiA9ICdPVFRPJztcbiAgICB3b2ZmID0gJ3dPRkYnO1xuICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmVyc2lvbiA9IGNocihkYXRhWzBdKSArIGNocihkYXRhWzFdKSArIGNocihkYXRhWzJdKSArIGNocihkYXRhWzNdKTtcbiAgICBpc1RURiA9IHZlcnNpb24gPT09IHR0ZjtcbiAgICBpc0NGRiA9IChpc1RURiA/IGZhbHNlIDogdmVyc2lvbiA9PT0gY2ZmKTtcbiAgICBpc1dPRkYgPSAoaXNDRkYgfHwgaXNUVEYgPyBmYWxzZSA6IHZlcnNpb24gPT09IHdvZmYpO1xuICAgIGlmIChpc1RURikge1xuICAgICAgdGhpcy5mb3JtYXQgPSBcInRydWV0eXBlXCI7XG4gICAgfSBlbHNlIGlmIChpc0NGRikge1xuICAgICAgdGhpcy5mb3JtYXQgPSBcIm9wZW50eXBlXCI7XG4gICAgfSBlbHNlIGlmIChpc1dPRkYpIHtcbiAgICAgIHRoaXMuZm9ybWF0ID0gXCJ3b2ZmXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yOiBmaWxlIGF0IFwiICsgdGhpcy51cmwgKyBcIiBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQgYXMgT3BlblR5cGUgZm9udC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByaW50Q2hhciA9IHRoaXMuZm9ybWF0ID09PSAndHJ1ZXR5cGUnIHx8IHRoaXMuZm9ybWF0ID09PSAnb3BlbnR5cGUnID8gdGhpcy5fdmVyaWZ5VFRGb3JPVEYoZGF0YSkgOiAnQSc7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwVmFsaWRhdGlvbihwcmludENoYXIpO1xuICB9O1xuXG4gIEZvbnQucHJvdG90eXBlLl92ZXJpZnlUVEZvck9URiA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgY2hlY2tUYWJsZUVycm9yLCBjbWFwMzE0LCBkZWx0YSwgZSwgZW5jb2RpbmdJRCwgZW5jb2RpbmdSZWNvcmQsIGVuZCwgZW5kQ2hhciwgaSwgbmV3aGV4LCBudW1UYWJsZXMsIG9mZnNldCwgcGxhdGZvcm1JRCwgcHJpbnRDaGFyLCBwcmludGFibGUsIHB0ciwgcnB0ciwgc2VnQ291bnQsIHRhZywgdGFnU3RhcnQsIHRhZ3MsIHVuaXRzUGVyRW0sIHZlcnNpb247XG4gICAgbnVtVGFibGVzID0gdXNob3J0KGRhdGFbNF0sIGRhdGFbNV0pO1xuICAgIHRhZ1N0YXJ0ID0gMTI7XG4gICAgcHRyID0gdm9pZCAwO1xuICAgIGVuZCA9IHRhZ1N0YXJ0ICsgMTYgKiBudW1UYWJsZXM7XG4gICAgdGFncyA9IHt9O1xuICAgIHRhZyA9IHZvaWQgMDtcbiAgICBwdHIgPSB0YWdTdGFydDtcbiAgICB3aGlsZSAocHRyIDwgZW5kKSB7XG4gICAgICB0YWcgPSBjaHIoZGF0YVtwdHJdKSArIGNocihkYXRhW3B0ciArIDFdKSArIGNocihkYXRhW3B0ciArIDJdKSArIGNocihkYXRhW3B0ciArIDNdKTtcbiAgICAgIHRhZ3NbdGFnXSA9IHtcbiAgICAgICAgbmFtZTogdGFnLFxuICAgICAgICBjaGVja3N1bTogdWxvbmcoZGF0YVtwdHIgKyA0XSwgZGF0YVtwdHIgKyA1XSwgZGF0YVtwdHIgKyA2XSwgZGF0YVtwdHIgKyA3XSksXG4gICAgICAgIG9mZnNldDogdWxvbmcoZGF0YVtwdHIgKyA4XSwgZGF0YVtwdHIgKyA5XSwgZGF0YVtwdHIgKyAxMF0sIGRhdGFbcHRyICsgMTFdKSxcbiAgICAgICAgbGVuZ3RoOiB1bG9uZyhkYXRhW3B0ciArIDEyXSwgZGF0YVtwdHIgKyAxM10sIGRhdGFbcHRyICsgMTRdLCBkYXRhW3B0ciArIDE1XSlcbiAgICAgIH07XG4gICAgICBwdHIgKz0gMTY7XG4gICAgfVxuICAgIGNoZWNrVGFibGVFcnJvciA9IGZ1bmN0aW9uKHRhZykge1xuICAgICAgaWYgKCF0YWdzW3RhZ10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3I6IGZvbnQgaXMgbWlzc2luZyB0aGUgcmVxdWlyZWQgT3BlblR5cGUgJ1wiICsgdGFnICsgXCInIHRhYmxlLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIHRhZyA9IGNoZWNrVGFibGVFcnJvcihcImhlYWRcIik7XG4gICAgaWYgKHRhZyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHRyID0gdGFnc1t0YWddLm9mZnNldDtcbiAgICB0YWdzW3RhZ10udmVyc2lvbiA9IFwiXCIgKyBkYXRhW3B0cl0gKyBkYXRhW3B0ciArIDFdICsgZGF0YVtwdHIgKyAyXSArIGRhdGFbcHRyICsgM107XG4gICAgdW5pdHNQZXJFbSA9IHVzaG9ydChkYXRhW3B0ciArIDE4XSwgZGF0YVtwdHIgKyAxOV0pO1xuICAgIHRoaXMubWV0cmljcy5xdWFkc2l6ZSA9IHVuaXRzUGVyRW07XG4gICAgdGFnID0gY2hlY2tUYWJsZUVycm9yKFwiaGhlYVwiKTtcbiAgICBpZiAodGFnID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdHIgPSB0YWdzW3RhZ10ub2Zmc2V0O1xuICAgIHRhZ3NbdGFnXS52ZXJzaW9uID0gXCJcIiArIGRhdGFbcHRyXSArIGRhdGFbcHRyICsgMV0gKyBkYXRhW3B0ciArIDJdICsgZGF0YVtwdHIgKyAzXTtcbiAgICB0aGlzLm1ldHJpY3MuYXNjZW50ID0gZndvcmQoZGF0YVtwdHIgKyA0XSwgZGF0YVtwdHIgKyA1XSkgLyB1bml0c1BlckVtO1xuICAgIHRoaXMubWV0cmljcy5kZXNjZW50ID0gZndvcmQoZGF0YVtwdHIgKyA2XSwgZGF0YVtwdHIgKyA3XSkgLyB1bml0c1BlckVtO1xuICAgIHRoaXMubWV0cmljcy5sZWFkaW5nID0gZndvcmQoZGF0YVtwdHIgKyA4XSwgZGF0YVtwdHIgKyA5XSkgLyB1bml0c1BlckVtO1xuICAgIHRhZyA9IGNoZWNrVGFibGVFcnJvcihcIk9TLzJcIik7XG4gICAgaWYgKHRhZyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHRyID0gdGFnc1t0YWddLm9mZnNldDtcbiAgICB0YWdzW3RhZ10udmVyc2lvbiA9IFwiXCIgKyBkYXRhW3B0cl0gKyBkYXRhW3B0ciArIDFdO1xuICAgIHRoaXMubWV0cmljcy53ZWlnaHRjbGFzcyA9IHVzaG9ydChkYXRhW3B0ciArIDRdLCBkYXRhW3B0ciArIDVdKTtcbiAgICB0YWcgPSBjaGVja1RhYmxlRXJyb3IoXCJjbWFwXCIpO1xuICAgIGlmICh0YWcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHB0ciA9IHRhZ3NbdGFnXS5vZmZzZXQ7XG4gICAgdGFnc1t0YWddLnZlcnNpb24gPSBcIlwiICsgZGF0YVtwdHJdICsgZGF0YVtwdHIgKyAxXTtcbiAgICBudW1UYWJsZXMgPSB1c2hvcnQoZGF0YVtwdHIgKyAyXSwgZGF0YVtwdHIgKyAzXSk7XG4gICAgZW5jb2RpbmdSZWNvcmQgPSB2b2lkIDA7XG4gICAgcnB0ciA9IHZvaWQgMDtcbiAgICBwbGF0Zm9ybUlEID0gdm9pZCAwO1xuICAgIGVuY29kaW5nSUQgPSB2b2lkIDA7XG4gICAgb2Zmc2V0ID0gdm9pZCAwO1xuICAgIGNtYXAzMTQgPSBmYWxzZTtcbiAgICBlbmNvZGluZ1JlY29yZCA9IDA7XG4gICAgd2hpbGUgKGVuY29kaW5nUmVjb3JkIDwgbnVtVGFibGVzKSB7XG4gICAgICBycHRyID0gcHRyICsgNCArIGVuY29kaW5nUmVjb3JkICogODtcbiAgICAgIHBsYXRmb3JtSUQgPSB1c2hvcnQoZGF0YVtycHRyXSwgZGF0YVtycHRyICsgMV0pO1xuICAgICAgZW5jb2RpbmdJRCA9IHVzaG9ydChkYXRhW3JwdHIgKyAyXSwgZGF0YVtycHRyICsgM10pO1xuICAgICAgb2Zmc2V0ID0gdWxvbmcoZGF0YVtycHRyICsgNF0sIGRhdGFbcnB0ciArIDVdLCBkYXRhW3JwdHIgKyA2XSwgZGF0YVtycHRyICsgN10pO1xuICAgICAgaWYgKHBsYXRmb3JtSUQgPT09IDMgJiYgZW5jb2RpbmdJRCA9PT0gMSkge1xuICAgICAgICBjbWFwMzE0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgZW5jb2RpbmdSZWNvcmQrKztcbiAgICB9XG4gICAgcHJpbnRDaGFyID0gXCJBXCI7XG4gICAgaWYgKGNtYXAzMTQgIT09IGZhbHNlKSB7XG4gICAgICBwdHIgKz0gY21hcDMxNDtcbiAgICAgIHZlcnNpb24gPSB1c2hvcnQoZGF0YVtwdHJdLCBkYXRhW3B0ciArIDFdKTtcbiAgICAgIGlmICh2ZXJzaW9uID09PSA0KSB7XG4gICAgICAgIHNlZ0NvdW50ID0gdXNob3J0KGRhdGFbcHRyICsgNl0sIGRhdGFbcHRyICsgN10pIC8gMjtcbiAgICAgICAgcHJpbnRhYmxlID0gZnVuY3Rpb24oY2hyKSB7XG4gICAgICAgICAgcmV0dXJuIFsweDAwMDksIDB4MDAwQSwgMHgwMDBCLCAweDAwMEMsIDB4MDAwRCwgMHgwMDIwLCAweDAwODUsIDB4MDBBMCwgMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMjgsIDB4MjAyOSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMF0uaW5kZXhPZihjaHIpID09PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgaSA9IHB0ciArIDE0O1xuICAgICAgICBlID0gcHRyICsgMTQgKyAyICogc2VnQ291bnQ7XG4gICAgICAgIGVuZENoYXIgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGkgPCBlKSB7XG4gICAgICAgICAgZW5kQ2hhciA9IHVzaG9ydChkYXRhW2ldLCBkYXRhW2kgKyAxXSk7XG4gICAgICAgICAgaWYgKHByaW50YWJsZShlbmRDaGFyKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZENoYXIgPSBmYWxzZTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZENoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgcHJpbnRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlbmRDaGFyKTtcbiAgICAgICAgICBkZWx0YSA9IC0oZW5kQ2hhciAtIDEpICsgNjU1MzY7XG4gICAgICAgICAgbmV3aGV4ID0gYnRvYShjaHIoMCkgKyBjaHIxNihlbmRDaGFyKSArIGNocjE2KDB4RkZGRikgKyBjaHIxNigwKSArIGNocjE2KGVuZENoYXIpICsgY2hyMTYoMHhGRkZGKSArIGNocjE2KGRlbHRhKSArIGNocjE2KDEpKTtcbiAgICAgICAgICB0aGlzLmJhc2U2NCA9IHRoaXMuYmFzZTY0LnN1YnN0cmluZygwLCAzODApICsgbmV3aGV4ICsgdGhpcy5iYXNlNjQuc3Vic3RyaW5nKDM4MCArIG5ld2hleC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmludENoYXI7XG4gIH07XG5cbiAgRm9udC5wcm90b3R5cGUuYm9vdHN0cmFwVmFsaWRhdGlvbiA9IGZ1bmN0aW9uKHByaW50Q2hhciwgdGltZW91dCkge1xuICAgIHZhciBjYW52YXMsIGNvbnRleHQsIGRlbGF5ZWRWYWxpZGF0ZSwgbG9jYWwsIHBhcmEsIHF1YWQsIHJlYWxmb250LCB0Zk5hbWUsIHplcm93aWR0aDtcbiAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICB0aW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuICAgIHRmTmFtZSA9IHRoaXMuZm9udEZhbWlseSArIFwiIHRlc3Rmb250XCI7XG4gICAgemVyb3dpZHRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIHplcm93aWR0aC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgemVyb3dpZHRoLmlubmVySFRNTCA9IFwiQGZvbnQtZmFjZSB7XFxuXCIgKyBcIiBmb250LWZhbWlseTogJ1wiICsgdGZOYW1lICsgXCInO1xcblwiICsgXCIgc3JjOiB1cmwoJ2RhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtiYXNlNjQsXCIgKyB0aGlzLmJhc2U2NCArIFwiJylcXG5cIiArIFwiIGZvcm1hdCgndHJ1ZXR5cGUnKTt9XCI7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh6ZXJvd2lkdGgpO1xuICAgIHJlYWxmb250ID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLnN5c3RlbWZvbnQpIHtcbiAgICAgIHJlYWxmb250ID0gdGhpcy50b1N0eWxlTm9kZSgpO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChyZWFsZm9udCk7XG4gICAgfVxuICAgIHBhcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICBwYXJhLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyBvcGFjaXR5OiAwO1wiO1xuICAgIHBhcmEuc3R5bGUuZm9udEZhbWlseSA9IFwiJ1wiICsgdGhpcy5mb250RmFtaWx5ICsgXCInLCAnXCIgKyB0Zk5hbWUgKyBcIidcIjtcbiAgICBwYXJhLmlubmVySFRNTCA9IHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhciArIHByaW50Q2hhcjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmEpO1xuICAgIGlmICghZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgdGhpcy5vbmxvYWQoKTtcbiAgICAgIHJldHVybiBlcnJvcihcIkVycm9yOiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblwiICsgXCJDb25zZXF1ZW50bHksIEZvbnQub25sb2FkKCkgY2Fubm90IGJlIHRydXN0ZWQuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWFkID0gKHRoaXMuc3lzdGVtZm9udCA/IDEwMDAgOiB0aGlzLm1ldHJpY3MucXVhZHNpemUpO1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHF1YWQ7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gcXVhZDtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjb250ZXh0LmZvbnQgPSBcIjFlbSAnXCIgKyB0aGlzLmZvbnRGYW1pbHkgKyBcIidcIjtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgtMSwgLTEsIHF1YWQgKyAyLCBxdWFkICsgMik7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoXCJ0ZXN0IHRleHRcIiwgNTAsIHF1YWQgLyAyKTtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICBsb2NhbCA9IHRoaXM7XG4gICAgICBkZWxheWVkVmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsLnZhbGlkYXRlKHBhcmEsIHplcm93aWR0aCwgcmVhbGZvbnQsIGxvY2FsLCB0aW1lb3V0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2V0VGltZW91dChkZWxheWVkVmFsaWRhdGUsIDUwKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgV2UgdGFrZSBhIGRpZmZlcmVudCBwYXRoIGZvciBTeXN0ZW0gZm9udHMsIGJlY2F1c2VcbiAgd2UgY2Fubm90IGluc3BlY3QgdGhlIGFjdHVhbCBieXRlIGNvZGUuXG4gICovXG5cblxuICBGb250LnByb3RvdHlwZS5wcm9jZXNzU3lzdGVtRm9udCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3lzdGVtZm9udCA9IHRydWU7XG4gICAgdGhpcy5tZXRyaWNzID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwVmFsaWRhdGlvbihcIkFcIiwgMTAwMCk7XG4gIH07XG5cbiAgLypcbiAgVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGZvbnQuc3JjIGlzIHNldCwgKHRoZSBiaW5kaW5nXG4gIGZvciB3aGljaCBpcyBhdCB0aGUgZW5kIG9mIHRoaXMgZmlsZSkuXG4gICovXG5cblxuICBGb250LnByb3RvdHlwZS5sb2FkRm9udCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb250LCB4aHI7XG4gICAgZm9udCA9IHRoaXM7XG4gICAgaWYgKHRoaXMudXJsLmluZGV4T2YoXCIuXCIpID09PSAtMSkge1xuICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb250LnByb2Nlc3NTeXN0ZW1Gb250KCk7XG4gICAgICB9KSwgMTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbihcIkdFVFwiLCBmb250LnVybCwgdHJ1ZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgYXJyYXlCdWZmZXI7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBsb2FkIGZyb20gXCIgKyB0aGlzLnVybCArIFwiLiBQbGVhc2UsIHZlcmlmeSBzb3VyY2UgdXJscy5cIik7XG4gICAgICB9XG4gICAgICBhcnJheUJ1ZmZlciA9IHhoci5yZXNwb25zZTtcbiAgICAgIGlmIChhcnJheUJ1ZmZlcikge1xuICAgICAgICBmb250LmRhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBmb250Lm9uZG93bmxvYWRlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZvbnQub25lcnJvcihcIkVycm9yIGRvd25sb2FkaW5nIGZvbnQgcmVzb3VyY2UgZnJvbSBcIiArIGZvbnQudXJsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB4aHIuc2VuZChudWxsKTtcbiAgfTtcblxuICAvKlxuICBHZXQgdGhlIERPTSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZvbnRcbiAgb2JqZWN0LCBmb3IgcGFnZS1pbmplY3Rpb24uXG4gICovXG5cblxuICBGb250LnByb3RvdHlwZS50b1N0eWxlTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHlsZXRleHQ7XG4gICAgaWYgKHRoaXMuc3R5bGVOb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZU5vZGU7XG4gICAgfVxuICAgIHRoaXMuc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIHRoaXMuc3R5bGVOb2RlLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgc3R5bGV0ZXh0ID0gXCJAZm9udC1mYWNlIHtcXG5cIjtcbiAgICBzdHlsZXRleHQgKz0gXCIgZm9udC1mYW1pbHk6ICdcIiArIHRoaXMuZm9udEZhbWlseSArIFwiJztcXG5cIjtcbiAgICBzdHlsZXRleHQgKz0gXCIgc3JjOiBsb2NhbCgnXCIgKyB0aGlzLmZvbnRGYW1pbHkgKyBcIicpLCB1cmwoJ1wiICsgdGhpcy51cmwgKyBcIicpIGZvcm1hdCgnXCIgKyB0aGlzLmZvcm1hdCArIFwiJyk7XFxuXCI7XG4gICAgc3R5bGV0ZXh0ICs9IFwifVwiO1xuICAgIHRoaXMuc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxldGV4dDtcbiAgICByZXR1cm4gdGhpcy5zdHlsZU5vZGU7XG4gIH07XG5cbiAgLypcbiAgTWVhc3VyZSBhIHNwZWNpZmljIHN0cmluZyBvZiB0ZXh0LCBnaXZlbiB0aGlzIGZvbnQuXG4gIElmIHRoZSB0ZXh0IGlzIHRvbyB3aWRlIGZvciBvdXIgcHJlYWxsb2NhdGVkIGNhbnZhcyxcbiAgaXQgd2lsbCBiZSBjaG9wcGVkIHVwIGFuZCB0aGUgc2VnbWVudHMgbWVhc3VyZWRcbiAgc2VwYXJhdGVseS5cbiAgKi9cblxuXG4gIEZvbnQucHJvdG90eXBlLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24odGV4dFN0cmluZykge1xuICAgIHZhciBpLCBtZXRyaWNzLCBtaW5TZWdtZW50cywgc2VnbWVudExlbmd0aCwgc2VnbWVudHM7XG4gICAgaWYgKCEodGhpcy5sb2FkZWQgJiYgIXRoaXMuc3lzdGVtZm9udCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lYXN1cmVUZXh0KCkgd2FzIGNhbGxlZCB3aGlsZSB0aGUgZm9udCB3YXMgbm90IHlldCBsb2FkZWRcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5mb250ID0gdGhpcy50b1N0cmluZygpO1xuICAgIG1ldHJpY3MgPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQodGV4dFN0cmluZyk7XG4gICAgbWV0cmljcy5mb250c2l6ZSA9IHRoaXMuZm9udFNpemU7XG4gICAgbWV0cmljcy5hc2NlbnQgPSAwO1xuICAgIG1ldHJpY3MuZGVzY2VudCA9IDA7XG4gICAgbWV0cmljcy5ib3VuZHMgPSB7XG4gICAgICBtaW54OiAwLFxuICAgICAgbWF4eDogbWV0cmljcy53aWR0aCxcbiAgICAgIG1pbnk6IDAsXG4gICAgICBtYXh5OiAwXG4gICAgfTtcbiAgICBtZXRyaWNzLmhlaWdodCA9IDA7XG4gICAgc2VnbWVudHMgPSBbXTtcbiAgICBtaW5TZWdtZW50cyA9IG1ldHJpY3Mud2lkdGggLyB0aGlzLm1ldHJpY3MucXVhZHNpemU7XG4gICAgaWYgKG1pblNlZ21lbnRzIDw9IDEpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2godGV4dFN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRzLnB1c2godGV4dFN0cmluZyk7XG4gICAgfVxuICAgIHNlZ21lbnRMZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgaSA9IHZvaWQgMDtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNlZ21lbnRMZW5ndGgpIHtcbiAgICAgIHRoaXMubWVhc3VyZVNlZ21lbnQoc2VnbWVudHNbaV0sIG1ldHJpY3MpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gbWV0cmljcztcbiAgfTtcblxuICAvKlxuICBNZWFzdXJlIGEgc2VjdGlvbiBvZiB0ZXh0LCBnaXZlbiB0aGlzIGZvbnQsIHRoYXQgaXNcbiAgZ3VhcmFudGVlZCB0byBmaXQgb24gb3VyIHByZWFsbG9jYXRlZCBjYW52YXMuXG4gICovXG5cblxuICBGb250LnByb3RvdHlwZS5tZWFzdXJlU2VnbWVudCA9IGZ1bmN0aW9uKHRleHRTZWdtZW50LCBtZXRyaWNzKSB7XG4gICAgdmFyIGFzY2VudCwgYmFzZWxpbmUsIGNhbnZhcywgY3R4LCBkZXNjZW50LCBnZXRDU1NWYWx1ZSwgaCwgaSwgaiwgbGVhZERpdiwgbGVhZERpdkhlaWdodCwgbGVuLCBtYXh4LCBtaWQsIG1pbngsIG51bUxpbmVzLCBwYWRkaW5nLCBwaXhlbERhdGEsIHF1YWQsIHNjYW5oZWlnaHQsIHNjYW53aWR0aCwgc3RlcCwgdywgdzQsIHhfb2Zmc2V0LCB4cG9zLCB5X29mZnNldDtcbiAgICBnZXRDU1NWYWx1ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICB9O1xuICAgIGkgPSB2b2lkIDA7XG4gICAgbGVhZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGVhZERpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBsZWFkRGl2LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIGxlYWREaXYuc3R5bGUuZm9udCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICBudW1MaW5lcyA9IDEwO1xuICAgIGxlYWREaXYuaW5uZXJIVE1MID0gdGV4dFNlZ21lbnQ7XG4gICAgaSA9IDE7XG4gICAgd2hpbGUgKGkgPCBudW1MaW5lcykge1xuICAgICAgbGVhZERpdi5pbm5lckhUTUwgKz0gXCI8YnIvPlwiICsgdGV4dFNlZ21lbnQ7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGVhZERpdik7XG4gICAgbWV0cmljcy5sZWFkaW5nID0gMS4yICogdGhpcy5mb250U2l6ZTtcbiAgICBsZWFkRGl2SGVpZ2h0ID0gZ2V0Q1NTVmFsdWUobGVhZERpdiwgXCJoZWlnaHRcIik7XG4gICAgbGVhZERpdkhlaWdodCA9IGxlYWREaXZIZWlnaHQucmVwbGFjZShcInB4XCIsIFwiXCIpO1xuICAgIGlmIChsZWFkRGl2SGVpZ2h0ID49IHRoaXMuZm9udFNpemUgKiBudW1MaW5lcykge1xuICAgICAgbWV0cmljcy5sZWFkaW5nID0gKGxlYWREaXZIZWlnaHQgLyBudW1MaW5lcykgfCAwO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxlYWREaXYpO1xuICAgIGlmICgvXlxccyokLy50ZXN0KHRleHRTZWdtZW50KSkge1xuICAgICAgcmV0dXJuIG1ldHJpY3M7XG4gICAgfVxuICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICBxdWFkID0gKHRoaXMuc3lzdGVtZm9udCA/IDEwMDAgOiB0aGlzLm1ldHJpY3MucXVhZHNpemUpO1xuICAgIHcgPSBxdWFkO1xuICAgIGggPSBxdWFkO1xuICAgIGJhc2VsaW5lID0gcXVhZCAvIDI7XG4gICAgcGFkZGluZyA9IDUwO1xuICAgIHhwb3MgPSAocXVhZCAtIG1ldHJpY3Mud2lkdGgpIC8gMjtcbiAgICBpZiAoeHBvcyAhPT0gKHhwb3MgfCAwKSkge1xuICAgICAgeHBvcyA9IHhwb3MgfCAwO1xuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgtcGFkZGluZywgLXBhZGRpbmcsIHcgKyAyICogcGFkZGluZywgaCArIDIgKiBwYWRkaW5nKTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgIGN0eC5maWxsVGV4dCh0ZXh0U2VnbWVudCwgeHBvcywgYmFzZWxpbmUpO1xuICAgIHNjYW53aWR0aCA9IChtZXRyaWNzLndpZHRoICsgcGFkZGluZykgfCAwO1xuICAgIHNjYW5oZWlnaHQgPSA0ICogdGhpcy5mb250U2l6ZTtcbiAgICB4X29mZnNldCA9IHhwb3MgLSBwYWRkaW5nIC8gMjtcbiAgICB5X29mZnNldCA9IGJhc2VsaW5lIC0gc2NhbmhlaWdodCAvIDI7XG4gICAgcGl4ZWxEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4X29mZnNldCwgeV9vZmZzZXQsIHNjYW53aWR0aCwgc2NhbmhlaWdodCkuZGF0YTtcbiAgICBpID0gMDtcbiAgICBqID0gMDtcbiAgICB3NCA9IHNjYW53aWR0aCAqIDQ7XG4gICAgbGVuID0gcGl4ZWxEYXRhLmxlbmd0aDtcbiAgICBtaWQgPSBzY2FuaGVpZ2h0IC8gMjtcbiAgICB3aGlsZSAoKytpIDwgbGVuICYmIHBpeGVsRGF0YVtpXSA9PT0gMjU1KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYXNjZW50ID0gKGkgLyB3NCkgfCAwO1xuICAgIGkgPSBsZW4gLSAxO1xuICAgIHdoaWxlICgtLWkgPiAwICYmIHBpeGVsRGF0YVtpXSA9PT0gMjU1KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZGVzY2VudCA9IChpIC8gdzQpIHwgMDtcbiAgICBpID0gMDtcbiAgICBqID0gMDtcbiAgICB3aGlsZSAoaiA8IHNjYW53aWR0aCAmJiBwaXhlbERhdGFbaV0gPT09IDI1NSkge1xuICAgICAgaSArPSB3NDtcbiAgICAgIGlmIChpID49IGxlbikge1xuICAgICAgICBqKys7XG4gICAgICAgIGkgPSAoaSAtIGxlbikgKyA0O1xuICAgICAgfVxuICAgIH1cbiAgICBtaW54ID0gajtcbiAgICBzdGVwID0gMTtcbiAgICBpID0gbGVuIC0gMztcbiAgICBqID0gMDtcbiAgICB3aGlsZSAoaiA8IHNjYW53aWR0aCAmJiBwaXhlbERhdGFbaV0gPT09IDI1NSkge1xuICAgICAgaSAtPSB3NDtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBqKys7XG4gICAgICAgIGkgPSAobGVuIC0gMykgLSAoc3RlcCsrKSAqIDQ7XG4gICAgICB9XG4gICAgfVxuICAgIG1heHggPSBzY2Fud2lkdGggLSBqO1xuICAgIG1ldHJpY3MuYXNjZW50ID0gbWlkIC0gYXNjZW50O1xuICAgIG1ldHJpY3MuZGVzY2VudCA9IGRlc2NlbnQgLSBtaWQ7XG4gICAgbWV0cmljcy5ib3VuZHMgPSB7XG4gICAgICBtaW54OiBtaW54IC0gKHBhZGRpbmcgLyAyKSxcbiAgICAgIG1heHg6IG1heHggLSAocGFkZGluZyAvIDIpLFxuICAgICAgbWlueTogLW1ldHJpY3MuZGVzY2VudCxcbiAgICAgIG1heHk6IG1ldHJpY3MuYXNjZW50XG4gICAgfTtcbiAgICBtZXRyaWNzLmhlaWdodCA9IDEgKyAoZGVzY2VudCAtIGFzY2VudCk7XG4gICAgcmV0dXJuIG1ldHJpY3M7XG4gIH07XG5cbiAgRm9udC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJcIiArIHRoaXMuZm9udFNpemUgKyBcInB4ICdcIiArIHRoaXMuZm9udEZhbWlseSArIFwiJ1wiO1xuICB9O1xuXG4gIHJldHVybiBGb250O1xuXG59KShUcmlnZ2VyYWJsZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRm9udDtcblxuLypcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWZvbnQubWFwXG4qL1xuIl19
;